
Patch from Coresystems.  Replaces the realmode entry point of Linux and
jumps directly to its 32-bit PE region.

Index: conf/i386-coreboot.rmk
===================================================================
--- conf/i386-coreboot.rmk	(revision 1749)
+++ conf/i386-coreboot.rmk	(working copy)
@@ -97,12 +97,12 @@
 	play.mod cpuid.mod serial.mod ata.mod
 
 # For _linux.mod.
-_linux_mod_SOURCES = loader/i386/pc/linux.c
+_linux_mod_SOURCES = loader/i386/coreboot/linux.c
 _linux_mod_CFLAGS = $(COMMON_CFLAGS)
 _linux_mod_LDFLAGS = $(COMMON_LDFLAGS)
 
 # For linux.mod.
-linux_mod_SOURCES = loader/i386/pc/linux_normal.c
+linux_mod_SOURCES = loader/i386/coreboot/linux_normal.c
 linux_mod_CFLAGS = $(COMMON_CFLAGS)
 linux_mod_LDFLAGS = $(COMMON_LDFLAGS)
 
Index: include/grub/i386/coreboot/linux.h
===================================================================
--- include/grub/i386/coreboot/linux.h	(revision 0)
+++ include/grub/i386/coreboot/linux.h	(revision 0)
@@ -0,0 +1,249 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2003,2004,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_LINUX_MACHINE_HEADER
+#define GRUB_LINUX_MACHINE_HEADER      1
+
+#define GRUB_LINUX_MAGIC_SIGNATURE     0x53726448      /* "HdrS" */
+#define GRUB_LINUX_DEFAULT_SETUP_SECTS 4
+#define GRUB_LINUX_FLAG_CAN_USE_HEAP   0x80
+#define GRUB_LINUX_INITRD_MAX_ADDRESS  0x37FFFFFF
+#define GRUB_LINUX_MAX_SETUP_SECTS     64
+#define GRUB_LINUX_BOOT_LOADER_TYPE    0x72
+#define GRUB_LINUX_HEAP_END_OFFSET     (0x9000 - 0x200)
+
+#define GRUB_LINUX_BZIMAGE_ADDR                0x100000
+#define GRUB_LINUX_ZIMAGE_ADDR         0x10000
+#define GRUB_LINUX_OLD_REAL_MODE_ADDR  0x90000
+#define GRUB_LINUX_SETUP_STACK         0x9000
+
+#define GRUB_LINUX_FLAG_BIG_KERNEL     0x1
+
+/* Linux's video mode selection support. Actually I hate it!  */
+#define GRUB_LINUX_VID_MODE_NORMAL     0xFFFF
+#define GRUB_LINUX_VID_MODE_EXTENDED   0xFFFE
+#define GRUB_LINUX_VID_MODE_ASK                0xFFFD
+
+#define GRUB_LINUX_CL_OFFSET           0x9000
+#define GRUB_LINUX_CL_END_OFFSET       0x90FF
+#define GRUB_LINUX_SETUP_MOVE_SIZE     0x9100
+#define GRUB_LINUX_CL_MAGIC            0xA33F
+
+#define GRUB_LINUX_EFI_SIGNATURE       \
+  ('E' << 24 | 'F' << 16 | 'I' << 8 | 'L')
+
+#define GRUB_LINUX_OFW_SIGNATURE       \
+  (' ' << 24 | 'W' << 16 | 'F' << 8 | 'O')
+
+#ifndef ASM_FILE
+
+/* For the Linux/i386 boot protocol version 2.03.  */
+struct linux_kernel_header
+{
+  grub_uint8_t code1[0x0020];
+  grub_uint16_t cl_magic;              /* Magic number 0xA33F */
+  grub_uint16_t cl_offset;             /* The offset of command line */
+  grub_uint8_t code2[0x01F1 - 0x0020 - 2 - 2];
+  grub_uint8_t setup_sects;            /* The size of the setup in sectors */
+  grub_uint16_t root_flags;            /* If the root is mounted readonly */
+  grub_uint16_t syssize;               /* obsolete */
+  grub_uint16_t swap_dev;              /* obsolete */
+  grub_uint16_t ram_size;              /* obsolete */
+  grub_uint16_t vid_mode;              /* Video mode control */
+  grub_uint16_t root_dev;              /* Default root device number */
+  grub_uint16_t boot_flag;             /* 0xAA55 magic number */
+  /* 2.00+ */
+  grub_uint16_t jump;                  /* Jump instruction */
+  grub_uint32_t header;                        /* Magic signature "HdrS" */
+  grub_uint16_t version;               /* Boot protocol version supported */
+  grub_uint32_t realmode_swtch;                /* Boot loader hook */
+  grub_uint16_t start_sys;             /* The load-low segment (obsolete) */
+  grub_uint16_t kernel_version;                /* Points to kernel version string */
+  grub_uint8_t type_of_loader;         /* Boot loader identifier */
+  grub_uint8_t loadflags;              /* Boot protocol option flags */
+  grub_uint16_t setup_move_size;       /* Move to high memory size */
+  grub_uint32_t code32_start;          /* Boot loader hook */
+  grub_uint32_t ramdisk_image;         /* initrd load address */
+  grub_uint32_t ramdisk_size;          /* initrd size */
+  grub_uint32_t bootsect_kludge;       /* obsolete */
+  /* 2.01+ */
+  grub_uint16_t heap_end_ptr;          /* Free memory after setup end */
+  grub_uint16_t pad1;                  /* Unused */
+  /* 2.02+ */
+  char *cmd_line_ptr;                  /* Points to the kernel command line */
+  /* 2.03+ */
+  grub_uint32_t initrd_addr_max;        /* Highest address for initrd */
+} __attribute__ ((packed));
+
+#define E820MAX 32                     /* number of entries in E820MAP */
+struct e820entry {
+  grub_uint64_t addr;                  /* start of memory segment */
+  grub_uint64_t size;                  /* size of memory segment */
+  grub_uint32_t type;                  /* type of memory segment */
+#define E820_RAM        1
+#define E820_RESERVED   2
+#define E820_ACPI       3 /* usable as RAM once ACPI tables have been read */
+#define E820_NVS        4
+};
+
+/* Boot parameters for Linux based on 2.6.12. This is used by the setup
+   sectors of Linux, and must be simulated by GRUB on EFI, because
+   the setup sectors depend on BIOS.  */
+struct linux_kernel_params
+{
+  grub_uint8_t video_cursor_x;         /* 0 */
+  grub_uint8_t video_cursor_y;
+
+  grub_uint16_t ext_mem;               /* 2 */
+
+  grub_uint16_t video_page;            /* 4 */
+  grub_uint8_t video_mode;             /* 6 */
+  grub_uint8_t video_width;            /* 7 */
+
+  grub_uint8_t padding1[0xa - 0x8];
+
+  grub_uint16_t video_ega_bx;          /* a */
+
+  grub_uint8_t padding2[0xe - 0xc];
+
+  grub_uint8_t video_height;           /* e */
+  grub_uint8_t have_vga;               /* f */
+  grub_uint16_t font_size;             /* 10 */
+
+  grub_uint16_t lfb_width;             /* 12 */
+  grub_uint16_t lfb_height;            /* 14 */
+  grub_uint16_t lfb_depth;             /* 16 */
+  grub_uint32_t lfb_base;              /* 18 */
+  grub_uint32_t lfb_size;              /* 1c */
+
+  grub_uint16_t cl_magic;              /* 20 */
+  grub_uint16_t cl_offset;
+
+  grub_uint16_t lfb_line_len;          /* 24 */
+  grub_uint8_t red_mask_size;          /* 26 */
+  grub_uint8_t red_field_pos;
+  grub_uint8_t green_mask_size;
+  grub_uint8_t green_field_pos;
+  grub_uint8_t blue_mask_size;
+  grub_uint8_t blue_field_pos;
+  grub_uint8_t reserved_mask_size;
+  grub_uint8_t reserved_field_pos;
+  grub_uint16_t vesapm_segment;                /* 2e */
+  grub_uint16_t vesapm_offset;         /* 30 */
+  grub_uint16_t lfb_pages;             /* 32 */
+  grub_uint16_t vesa_attrib;           /* 34 */
+
+  grub_uint8_t padding3[0x40 - 0x36];
+
+  grub_uint16_t apm_version;           /* 40 */
+  grub_uint16_t apm_code_segment;      /* 42 */
+  grub_uint32_t apm_entry;             /* 44 */
+  grub_uint16_t apm_16bit_code_segment;        /* 48 */
+  grub_uint16_t apm_data_segment;      /* 4a */
+  grub_uint16_t apm_flags;             /* 4c */
+  grub_uint32_t apm_code_len;          /* 4e */
+  grub_uint16_t apm_data_len;          /* 52 */
+
+  grub_uint8_t padding4[0x60 - 0x54];
+
+  grub_uint32_t ist_signature;         /* 60 */
+  grub_uint32_t ist_command;           /* 64 */
+  grub_uint32_t ist_event;             /* 68 */
+  grub_uint32_t ist_perf_level;                /* 6c */
+
+  grub_uint8_t padding5[0x80 - 0x70];
+
+  grub_uint8_t hd0_drive_info[0x10];   /* 80 */
+  grub_uint8_t hd1_drive_info[0x10];   /* 90 */
+  grub_uint16_t rom_config_len;                /* a0 */
+
+  grub_uint8_t padding6[0xb0 - 0xa2];
+
+  grub_uint32_t ofw_signature;         /* b0 */
+  grub_uint32_t ofw_num_items;         /* b4 */
+  grub_uint32_t ofw_cif_handler;       /* b8 */
+  grub_uint32_t ofw_idt;               /* bc */
+
+  grub_uint8_t padding7[0x1c0 - 0xc0];
+
+  grub_uint32_t efi_signature;         /* 1c0 */
+  grub_uint32_t efi_system_table;      /* 1c4 */
+  grub_uint32_t efi_mem_desc_size;     /* 1c8 */
+  grub_uint32_t efi_mem_desc_version;  /* 1cc */
+  grub_uint32_t efi_mmap;              /* 1d0 */
+  grub_uint32_t efi_mmap_size;         /* 1d4 */
+
+  grub_uint8_t padding8[0x1e0 - 0x1d8];
+
+  grub_uint32_t alt_mem;               /* 1e0 */
+
+  grub_uint8_t padding9[0x1e8 - 0x1e4];
+
+  grub_uint32_t mmap_size;             /* 1e8 */
+
+  grub_uint8_t padding10[0x1f2 - 0x1ec];
+
+  grub_uint16_t mount_root_rdonly;     /* 1f2 */
+
+  grub_uint8_t padding11[0x1f8 - 0x1f4];
+
+  grub_uint16_t ramdisk_flags;         /* 1f8 */
+
+  grub_uint8_t padding12[0x1fc - 0x1fa];
+
+  grub_uint16_t orig_root_dev;         /* 1fc */
+
+  grub_uint8_t padding13[0x1ff - 0x1fe];
+
+  grub_uint8_t ps_mouse;               /* 1ff */
+
+  grub_uint8_t padding14[0x202 - 0x200];
+
+  grub_uint8_t param_block_signature[4]; /* 202 */
+  grub_uint16_t param_block_version;   /* 206 */
+
+  grub_uint8_t padding15[0x210 - 0x208];
+
+  grub_uint8_t loader_type;            /* 210 */
+  grub_uint8_t loader_flags;           /* 211 */
+
+  grub_uint8_t padding16[0x214 - 0x212];
+
+  grub_uint32_t kernel_start;          /* 0x214 */
+  grub_uint32_t initrd_start;          /* 0x218 */
+  grub_uint32_t initrd_size;           /* 0x21c */
+
+  grub_uint8_t padding17[0x228 - 0x220];
+
+  char *cmd_line_ptr;              /* 0x228 */
+  grub_uint32_t initrd_addr_max;
+
+  grub_uint8_t padding18[0x2d0 - 0x230];
+
+  struct e820entry e820_map[E820MAX]; /* 0x2d0 */
+
+  grub_uint8_t padding19[0x800 - 0x550];
+
+#define COMMAND_LINE_SIZE 256
+  grub_uint8_t  command_line[COMMAND_LINE_SIZE]; /* 0x800 */
+  grub_uint8_t padding20[0x1000 - 0x900];
+} __attribute__ ((packed));
+
+#endif /* ! ASM_FILE */
+
+#endif /* ! GRUB_LINUX_MACHINE_HEADER */
Index: loader/i386/coreboot/linux.c
===================================================================
--- loader/i386/coreboot/linux.c	(revision 0)
+++ loader/i386/coreboot/linux.c	(revision 0)
@@ -0,0 +1,461 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2006,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/loader.h>
+#include <grub/machine/loader.h>
+#include <grub/machine/memory.h>
+#include <grub/file.h>
+#include <grub/disk.h>
+#include <grub/err.h>
+#include <grub/misc.h>
+#include <grub/types.h>
+#include <grub/rescue.h>
+#include <grub/dl.h>
+#include <grub/mm.h>
+#include <grub/term.h>
+#include <grub/machine/linux.h>
+
+static grub_dl_t my_mod;
+
+static grub_size_t linux_mem_size;
+static int loaded;
+
+typedef struct {
+       grub_uint16_t limit_0;
+       grub_uint16_t base_0;
+       grub_uint8_t base_16;
+       grub_uint8_t types;
+       grub_uint8_t flags;
+       grub_uint8_t base_24;
+} segment_descriptor_t;
+
+static const segment_descriptor_t gdts[2] = {
+       { 0xffff, 0x0000, 0x00, 0x9f, 0xcf, 0x00 }, // flat code segment
+       { 0xffff, 0x0000, 0x00, 0x93, 0xcf, 0x00 }, // flat data segment
+};
+
+typedef struct {
+    grub_uint16_t ss;
+    grub_uint16_t gdt_limit;
+    grub_uint32_t gdt_base;
+    grub_uint32_t edi;
+    grub_uint32_t esi;
+    grub_uint32_t ebp;
+    grub_uint32_t esp;
+    grub_uint32_t ebx;
+    grub_uint32_t edx;
+    grub_uint32_t ecx;
+    grub_uint32_t eax;
+    grub_uint32_t gs;
+    grub_uint32_t fs;
+    grub_uint32_t es;
+    grub_uint32_t ds;
+    grub_uint32_t eflags;
+    grub_uint32_t eip;
+    grub_uint32_t cs;
+} context_t;
+
+#define LINUX_PARAM_LOC 0x90000
+#define COMMAND_LINE_LOC 0x91000
+#define GDT_LOC 0x92000
+#define GDT_LIMIT ( 0x08 * 14 - 1 )
+#define STACK_LOC 0x93000
+
+/* Setup a new context using the given stack.
+ */
+#define FLAT_CS 0x10
+#define FLAT_DS 0x18
+grub_err_t
+grub_linux_boot (void)
+{
+  struct linux_kernel_header *lh;
+  context_t *linux_context;
+
+  segment_descriptor_t * linux_gdt = (segment_descriptor_t *) GDT_LOC;
+  grub_memset(linux_gdt, 0, 14*sizeof(segment_descriptor_t));
+  linux_gdt[2] = gdts[0];
+  linux_gdt[3] = gdts[1];
+  linux_gdt[12] = gdts[0];
+  linux_gdt[13] = gdts[1];
+
+  lh = (struct linux_kernel_header *)LINUX_PARAM_LOC;
+
+  linux_context = (context_t *)(STACK_LOC + 4096 - (sizeof(*linux_context)));
+  grub_memset(linux_context, 0, sizeof(*linux_context));
+
+  /* Linux will work with these values */
+  linux_context->gdt_base = GDT_LOC;
+  linux_context->gdt_limit = GDT_LIMIT;
+  linux_context->cs = FLAT_CS;
+  linux_context->ds = FLAT_DS;
+  linux_context->es = FLAT_DS;
+  linux_context->fs = FLAT_DS;
+  linux_context->gs = FLAT_DS;
+  linux_context->ss = FLAT_DS;
+  linux_context->esp = (grub_uint32_t)(&(linux_context)->gs);
+  linux_context->esi = LINUX_PARAM_LOC;
+  linux_context->eip = lh->code32_start;
+
+  asm volatile (
+    "movl    %0, %%esi\n"
+    "movzwl  (%%esi), %%edx\n"
+    "movl    20(%%esi), %%eax\n"
+    "lgdt    2(%%esi)\n"
+    "movl    %%edx, %%ss\n"
+    "leal    -32(%%eax), %%esp\n"
+    "popal\n"
+    "popl    %%gs\n"
+    "popl    %%fs\n"
+    "popl    %%es\n"
+    "popl    %%ds\n"
+    "popfl\n"
+    "lret\n" : : "m" (linux_context)
+  );
+
+  /* Never reach here.  */
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_linux_unload (void)
+{
+  grub_dl_unref (my_mod);
+  loaded = 0;
+  return GRUB_ERR_NONE;
+}
+
+void
+grub_rescue_cmd_linux (int argc, char *argv[])
+{
+  grub_file_t file = 0;
+  struct linux_kernel_header lh;
+  struct linux_kernel_params *params;
+  grub_uint8_t setup_sects;
+  grub_size_t real_size, prot_size;
+  grub_ssize_t len;
+  int i;
+  char *dest;
+  grub_uint64_t top_ram;
+  char kernel_version[256];
+
+  auto int memory_hook(mem_region_t);
+  int memory_hook(mem_region_t mem_region)
+  {
+      grub_dprintf("linux", "addr=%x, size=%x, type=%x\n",
+                     (grub_uint32_t)mem_region->addr,
+                     (grub_uint32_t)mem_region->size, (grub_uint32_t)mem_region->type);
+      params->e820_map[i].addr = mem_region->addr;
+      params->e820_map[i].size = mem_region->size;
+      params->e820_map[i].type = mem_region->type;
+      i++;
+      return 0;
+  }
+
+  grub_dl_ref (my_mod);
+
+  if (argc == 0)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, "no kernel specified");
+      goto fail;
+    }
+
+  file = grub_file_open (argv[0]);
+  if (! file)
+    goto fail;
+
+  if (grub_file_read (file, (char *) &lh, sizeof (lh)) != sizeof (lh))
+    {
+      grub_error (GRUB_ERR_READ_ERROR, "cannot read the linux header");
+      goto fail;
+    }
+
+  if (lh.boot_flag != grub_cpu_to_le16 (0xaa55))
+    {
+      grub_error (GRUB_ERR_BAD_OS, "invalid magic number");
+      goto fail;
+    }
+
+  if (lh.setup_sects > GRUB_LINUX_MAX_SETUP_SECTS)
+    {
+      grub_error (GRUB_ERR_BAD_OS, "too many setup sectors");
+      goto fail;
+    }
+
+  setup_sects = lh.setup_sects;
+
+  /* If SETUP_SECTS is not set, set it to the default (4).  */
+  if (! setup_sects)
+    setup_sects = GRUB_LINUX_DEFAULT_SETUP_SECTS;
+
+  real_size = setup_sects << GRUB_DISK_SECTOR_BITS;
+  prot_size = grub_file_size (file) - real_size - GRUB_DISK_SECTOR_SIZE;
+
+  /* Prepare kernel parameters */
+
+  /* Any changes happen in the real location */
+  params = (struct linux_kernel_params *) LINUX_PARAM_LOC;
+  grub_memset (params, 0, sizeof(struct linux_kernel_params));
+
+  params->loader_type = 1; // 0x70;
+
+  /* XXX our boot command wants this */
+  params->kernel_start = lh.code32_start;
+  params->param_block_version = lh.version;
+  params->initrd_addr_max = lh.initrd_addr_max;
+
+  /* copy over some useful information */
+  params->mount_root_rdonly = lh.root_flags;
+  params->orig_root_dev = lh.root_dev;
+
+  /* FIXME this is only correct if the current console is vga */
+  params->video_cursor_x = grub_getxy() >> 8;
+  params->video_cursor_y = grub_getxy() & 0xff;
+  params->video_mode = 3; /* XXX */
+  params->video_width = (grub_getwh () >> 8);
+  params->video_height = (grub_getwh () & 0xff);
+  params->have_vga = 1;
+  params->font_size = 16; /* XXX */
+
+  /* Handle kernel command line parameters */
+  if (lh.version >= 0x202)
+    {
+      params->cmd_line_ptr = (char *) LINUX_PARAM_LOC + GRUB_LINUX_CL_OFFSET;
+    }
+  else
+    {
+      params->cl_magic = GRUB_LINUX_CL_MAGIC;
+      params->cl_offset = GRUB_LINUX_CL_END_OFFSET;
+    }
+
+  /* Iterators, nested functions and variables from
+   * higher scopes. What a wonderful world.
+   */
+  i=0;
+  grub_available_iterate(memory_hook);
+  params->mmap_size = i;
+
+  top_ram = params->e820_map[i-1].addr + params->e820_map[i-1].size;
+
+  params->alt_mem = ((top_ram - 0x100000) >> 10);
+  if (top_ram > (64ULL << 20))
+    {
+      params->ext_mem = (63 << 10);
+    }
+  else
+    {
+      params->ext_mem = params->alt_mem;
+    }
+
+  grub_dprintf("linux", "ext_mem=%dK, alt_mem=%dK\n", params->ext_mem, params->alt_mem);
+
+  grub_memset(kernel_version, 0, sizeof(kernel_version));
+  if (lh.version >= 0x200 && lh.kernel_version)
+    {
+      kernel_version[0] = ' ';
+      kernel_version[255] = 0;
+      grub_file_seek (file, GRUB_DISK_SECTOR_SIZE + lh.kernel_version);
+      grub_file_read (file, kernel_version+1, 254);
+    }
+
+  /* Now we're almost done */
+  grub_dprintf("linux", "setup=0x%x, size=0x%x, protocol=0x%x\n",
+                 real_size, prot_size, lh.version);
+
+  grub_printf ("   [Linux%s]\n", kernel_version);
+
+  grub_file_seek (file, real_size + GRUB_DISK_SECTOR_SIZE);
+
+  /* Detect explicitly specified memory size, if any.  */
+  linux_mem_size = 0;
+  for (i = 1; i < argc; i++)
+    if (grub_memcmp (argv[i], "mem=", 4) == 0)
+      {
+       char *val = argv[i] + 4;
+
+       linux_mem_size = grub_strtoul (val, &val, 0);
+
+       if (grub_errno)
+         {
+           grub_errno = GRUB_ERR_NONE;
+           linux_mem_size = 0;
+         }
+       else
+         {
+           int shift = 0;
+
+           switch (grub_tolower (val[0]))
+             {
+             case 'g':
+               shift += 10;
+             case 'm':
+               shift += 10;
+             case 'k':
+               shift += 10;
+             default:
+               break;
+             }
+
+           /* Check an overflow.  */
+           if (linux_mem_size > (~0UL >> shift))
+             linux_mem_size = 0;
+           else
+             linux_mem_size <<= shift;
+         }
+      }
+
+  /* Specify the boot file.  */
+  dest = grub_stpcpy ((char *) LINUX_PARAM_LOC + GRUB_LINUX_CL_OFFSET,
+                     "BOOT_IMAGE=");
+  dest = grub_stpcpy (dest, argv[0]);
+
+  /* Copy kernel parameters.  */
+  for (i = 1;
+       i < argc
+        && dest + grub_strlen (argv[i]) + 1 < ((char *) LINUX_PARAM_LOC
+                                               + GRUB_LINUX_CL_END_OFFSET);
+       i++)
+    {
+      *dest++ = ' ';
+      dest = grub_stpcpy (dest, argv[i]);
+    }
+
+  len = prot_size;
+  if (grub_file_read (file, (char *) GRUB_LINUX_BZIMAGE_ADDR, len) != len)
+    grub_error (GRUB_ERR_FILE_READ_ERROR, "Couldn't read file");
+
+  if (grub_errno == GRUB_ERR_NONE)
+    {
+      grub_loader_set (grub_linux_boot, grub_linux_unload, 1);
+      loaded = 1;
+    }
+
+ fail:
+
+  if (file)
+    grub_file_close (file);
+
+  if (grub_errno != GRUB_ERR_NONE)
+    {
+      grub_dl_unref (my_mod);
+      loaded = 0;
+    }
+}
+
+void
+grub_rescue_cmd_initrd (int argc, char *argv[])
+{
+  grub_file_t file = 0;
+  grub_ssize_t size;
+  grub_addr_t addr_min, addr_max;
+  grub_addr_t addr;
+  struct linux_kernel_header *lh;
+
+  if (argc == 0)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, "No module specified");
+      goto fail;
+    }
+
+  if (! loaded)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, "You need to load the kernel first.");
+      goto fail;
+    }
+
+  file = grub_file_open (argv[0]);
+  if (! file)
+    goto fail;
+
+  size = grub_file_size (file);
+
+  lh = (struct linux_kernel_header *) LINUX_PARAM_LOC;
+
+  /* Get the highest address available for the initrd.  */
+  if (grub_le_to_cpu16 (lh->version) >= 0x0203)
+    {
+      addr_max = grub_cpu_to_le32 (lh->initrd_addr_max);
+
+      /* XXX in reality, Linux specifies a bogus value, so
+        it is necessary to make sure that ADDR_MAX does not exceed
+        0x3fffffff.  */
+      if (addr_max > GRUB_LINUX_INITRD_MAX_ADDRESS)
+       addr_max = GRUB_LINUX_INITRD_MAX_ADDRESS;
+    }
+  else
+    addr_max = GRUB_LINUX_INITRD_MAX_ADDRESS;
+
+  if (linux_mem_size != 0 && linux_mem_size < addr_max)
+    addr_max = linux_mem_size;
+
+  /* Linux 2.3.xx has a bug in the memory range check, so avoid
+     the last page.
+     Linux 2.2.xx has a bug in the memory range check, which is
+     worse than that of Linux 2.3.xx, so avoid the last 64kb.  */
+  addr_max -= 0x10000;
+
+  addr_min = (grub_addr_t) grub_linux_tmp_addr + GRUB_LINUX_CL_END_OFFSET;
+
+  file = grub_file_open (argv[0]);
+  if (!file)
+    goto fail;
+
+  size = grub_file_size (file);
+
+  /* Put the initrd as high as possible, 4Ki aligned.  */
+  addr = (addr_max - size) & ~0xFFF;
+
+  if (addr < addr_min)
+    {
+      grub_error (GRUB_ERR_OUT_OF_RANGE, "The initrd is too big");
+      goto fail;
+    }
+
+  if (grub_file_read (file, (void *)addr, size) != size)
+    {
+      grub_error (GRUB_ERR_FILE_READ_ERROR, "Couldn't read file");
+      goto fail;
+    }
+
+  grub_printf ("   [Initrd, addr=0x%x, size=0x%x]\n",
+              addr, size);
+
+  lh->ramdisk_image = addr;
+  lh->ramdisk_size = size;
+
+ fail:
+  if (file)
+    grub_file_close (file);
+}
+
+
+GRUB_MOD_INIT(linux)
+{
+  grub_rescue_register_command ("linux",
+                               grub_rescue_cmd_linux,
+                               "load linux");
+  grub_rescue_register_command ("initrd",
+                               grub_rescue_cmd_initrd,
+                               "load initrd");
+  my_mod = mod;
+}
+
+GRUB_MOD_FINI(linux)
+{
+  grub_rescue_unregister_command ("linux");
+  grub_rescue_unregister_command ("initrd");
+}
Index: loader/i386/coreboot/linux_normal.c
===================================================================
--- loader/i386/coreboot/linux_normal.c	(revision 0)
+++ loader/i386/coreboot/linux_normal.c	(revision 0)
@@ -0,0 +1,60 @@
+/* linux_normal.c - boot another boot loader */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2004,2005,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/machine/loader.h>
+#include <grub/err.h>
+#include <grub/normal.h>
+#include <grub/dl.h>
+
+static grub_err_t
+grub_normal_linux_command (struct grub_arg_list *state __attribute__ ((unused)),
+                          int argc, char **args)
+{
+  grub_rescue_cmd_linux (argc, args);
+  return grub_errno;
+}
+
+
+static grub_err_t
+grub_normal_initrd_command (struct grub_arg_list *state __attribute__ ((unused)),
+                           int argc, char **args)
+{
+  grub_rescue_cmd_initrd (argc, args);
+  return grub_errno;
+}
+
+GRUB_MOD_INIT(linux_normal)
+{
+  (void) mod; /* To stop warning.  */
+  grub_register_command ("linux", grub_normal_linux_command,
+                        GRUB_COMMAND_FLAG_BOTH,
+                        "linux FILE [ARGS...]",
+                        "Load a linux kernel.", 0);
+
+  grub_register_command ("initrd", grub_normal_initrd_command,
+                        GRUB_COMMAND_FLAG_BOTH,
+                        "initrd FILE",
+                        "Load an initrd.", 0);
+}
+
+GRUB_MOD_FINI(linux_normal)
+{
+  grub_unregister_command ("linux");
+  grub_unregister_command ("initrd");
+}
