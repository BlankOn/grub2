
Based on tarball as published by Patrick Georgi on:

  http://code.google.com/p/google-summer-of-code-2007-coresystems/downloads/list

diff -Nur grub2-lb.old/conf/i386-linuxbios.rmk grub2-lb/conf/i386-linuxbios.rmk
--- grub2-lb.old/conf/i386-linuxbios.rmk	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/conf/i386-linuxbios.rmk	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,76 @@
+
+# -*- makefile -*-
+
+COMMON_ASFLAGS = -nostdinc -fno-builtin -m32
+COMMON_CFLAGS = -fno-builtin -mrtd -mregparm=3 -m32
+COMMON_LDFLAGS = -m32 -nostdlib
+
+# Images.
+pkgdata_PROGRAMS = kernel.elf
+
+MOSTLYCLEANFILES += kernel_elf_symlist.c kernel_syms.lst
+DEFSYMFILES += kernel_syms.lst
+
+kernel_elf_SOURCES = kern/i386/linuxbios/crt0.S kern/i386/linuxbios/cmain.c \
+	kern/main.c kern/device.c 		\
+	kern/disk.c kern/dl.c kern/err.c kern/file.c kern/fs.c 		\
+	kern/misc.c kern/mm.c kern/loader.c kern/rescue.c kern/term.c 	\
+	kern/parser.c kern/partition.c kern/env.c kern/i386/dl.c 	\
+	kern/i386/linuxbios/console.c \
+	kernel_elf_symlist.c
+kernel_elf_HEADERS = arg.h boot.h cache.h device.h disk.h dl.h elf.h elfload.h \
+	env.h err.h file.h fs.h kernel.h misc.h mm.h net.h parser.h rescue.h \
+	symbol.h term.h types.h loader.h partition.h \
+	pc_partition.h machine/time.h machine/init.h machine/loader.h
+kernel_elf_CFLAGS = $(COMMON_CFLAGS)
+kernel_elf_ASFLAGS = $(COMMON_ASFLAGS)
+kernel_elf_LDFLAGS = $(COMMON_LDFLAGS) -static-libgcc -lgcc \
+	-Wl,-N,-S,-Ttext,0x10000,-Bstatic
+
+kernel_elf_symlist.c: $(addprefix include/grub/,$(kernel_elf_HEADERS)) config.h gensymlist.sh
+	/bin/sh gensymlist.sh $(filter %.h,$^) > $@ || (rm -f $@; exit 1)
+
+kernel_syms.lst: $(addprefix include/grub/,$(kernel_elf_HEADERS)) config.h genkernsyms.sh
+	/bin/sh genkernsyms.sh $(filter %.h,$^) > $@ || (rm -f $@; exit 1)
+
+# Utilities.
+bin_UTILITIES = grub-mkimage
+ 
+# For grub-mkimage.
+grub_mkimage_SOURCES = util/i386/linuxbios/grub-mkimage.c util/misc.c \
+        util/resolve.c 
+
+# Modules.
+pkgdata_MODULES = normal.mod serial.mod _multiboot.mod multiboot.mod
+
+# For normal.mod.
+normal_mod_DEPENDENCIES = grub_script.tab.c grub_script.tab.h
+normal_mod_SOURCES = normal/arg.c normal/cmdline.c normal/command.c	\
+	normal/completion.c normal/execute.c		 		\
+	normal/function.c normal/lexer.c normal/main.c normal/menu.c	\
+	normal/menu_entry.c normal/misc.c grub_script.tab.c 		\
+	normal/script.c normal/i386/setjmp.S
+normal_mod_CFLAGS = $(COMMON_CFLAGS)
+normal_mod_LDFLAGS = $(COMMON_LDFLAGS)
+normal_mod_ASFLAGS = $(COMMON_ASFLAGS)
+
+# For serial.mod.
+serial_mod_SOURCES = term/i386/pc/serial.c
+serial_mod_CFLAGS = $(COMMON_CFLAGS)
+serial_mod_LDFLAGS = $(COMMON_LDFLAGS)
+
+# For _multiboot.mod.
+_multiboot_mod_SOURCES = loader/i386/pc/multiboot.c \
+                         loader/i386/pc/multiboot2.c \
+                         loader/multiboot2.c \
+                         loader/multiboot_loader.c
+_multiboot_mod_CFLAGS = $(COMMON_CFLAGS)
+_multiboot_mod_LDFLAGS = $(COMMON_LDFLAGS)
+
+# For multiboot.mod.
+multiboot_mod_SOURCES = loader/multiboot_loader_normal.c
+multiboot_mod_CFLAGS = $(COMMON_CFLAGS)
+multiboot_mod_LDFLAGS = $(COMMON_LDFLAGS)
+
+include $(srcdir)/conf/common.mk
+
diff -Nur grub2-lb.old/configure.ac grub2-lb/configure.ac
--- grub2-lb.old/configure.ac	2007-05-17 21:03:42.000000000 +0200
+++ grub2-lb/configure.ac	2007-10-04 14:38:15.000000000 +0200
@@ -77,6 +77,7 @@
 # Sanity check.
 case "$target_cpu"-"$platform" in
   i386-efi) ;;
+  i386-linuxbios) ;;
   i386-pc) ;;
   powerpc-ieee1275) ;;
   sparc64-ieee1275) ;;
diff -Nur grub2-lb.old/disk/i386/linuxbios/grubcompat.h grub2-lb/disk/i386/linuxbios/grubcompat.h
--- grub2-lb.old/disk/i386/linuxbios/grubcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/grubcompat.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,45 @@
+#ifndef GRUB_COMPAT
+#define GRUB_COMPAT
+
+#define CONFIG_LITTLE_ENDIAN
+#define CONFIG_IDE_LBA48
+
+#include <grub/types.h>
+#include <grub/misc.h>
+
+#define u8 grub_uint8_t
+#define u16 grub_uint16_t
+#define u32 grub_uint32_t
+#define u64 grub_uint64_t
+
+#define __be32_to_cpu grub_be_to_cpu32
+#define __be16_to_cpu grub_be_to_cpu16
+#define __le32_to_cpu grub_le_to_cpu32
+#define __le16_to_cpu grub_le_to_cpu16
+
+#define printk grub_printf
+#define strcpy grub_strcpy
+#define memset grub_memset
+
+#define NULL 0
+
+#include "io.h"
+#include "timer.h"
+
+static void load_timer2(unsigned int ticks)
+{
+	/* Set up the timer gate, turn off the speaker */
+	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
+	outb(TIMER2_SEL | WORD_ACCESS | MODE0 | BINARY_COUNT,
+	     TIMER_MODE_PORT);
+	outb(ticks & 0xFF, TIMER2_PORT);
+	outb(ticks >> 8, TIMER2_PORT);
+}
+
+void udelay(unsigned int usecs)
+{
+	load_timer2((usecs * TICKS_PER_MS) / 1000);
+	while ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
+}
+
+#endif
diff -Nur grub2-lb.old/disk/i386/linuxbios/io.h grub2-lb/disk/i386/linuxbios/io.h
--- grub2-lb.old/disk/i386/linuxbios/io.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/io.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,51 @@
+#ifndef _ASM_IO_H
+#define _ASM_IO_H
+
+extern unsigned long virt_offset;
+
+#define phys_to_virt(phys) ((void *) ((unsigned long) (phys) - virt_offset))
+#define virt_to_phys(virt) ((unsigned long) (virt) + virt_offset)
+
+#define __SLOW_DOWN_IO "outb %%al,$0x80;"
+static inline void slow_down_io(void) 
+{
+	__asm__ __volatile__( 
+		__SLOW_DOWN_IO
+#ifdef REALLY_SLOW_IO
+		__SLOW_DOWN_IO __SLOW_DOWN_IO __SLOW_DOWN_IO
+#endif
+		: : );
+}
+
+#define BUILDIO(bwl,bw,type) \
+static inline void out##bwl(unsigned type value, int port) { \
+	__asm__ __volatile__("out" #bwl " %" #bw "0, %w1" : : "a"(value), "Nd"(port)); \
+} \
+static inline unsigned type in##bwl(int port) { \
+	unsigned type value; \
+	__asm__ __volatile__("in" #bwl " %w1, %" #bw "0" : "=a"(value) : "Nd"(port)); \
+	return value; \
+} \
+static inline void out##bwl##_p(unsigned type value, int port) { \
+	out##bwl(value, port); \
+	slow_down_io(); \
+} \
+static inline unsigned type in##bwl##_p(int port) { \
+	unsigned type value = in##bwl(port); \
+	slow_down_io(); \
+	return value; \
+} \
+static inline void outs##bwl(int port, const void *addr, unsigned long count) { \
+	__asm__ __volatile__("rep; outs" #bwl : "+S"(addr), "+c"(count) : "d"(port)); \
+} \
+static inline void ins##bwl(int port, void *addr, unsigned long count) { \
+	__asm__ __volatile__("rep; ins" #bwl : "+D"(addr), "+c"(count) : "d"(port)); \
+}
+
+#ifndef BOOTSTRAP
+BUILDIO(b,b,char)
+BUILDIO(w,w,short)
+BUILDIO(l,,int)
+#endif
+
+#endif
diff -Nur grub2-lb.old/disk/i386/linuxbios/timer.h grub2-lb/disk/i386/linuxbios/timer.h
--- grub2-lb.old/disk/i386/linuxbios/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/timer.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,61 @@
+/* Taken from Etherboot */
+/* Defines for routines to implement a low-overhead timer for drivers */
+
+ /*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+#ifndef	TIMER_H
+#define TIMER_H
+
+/* Ports for the 8254 timer chip */
+#define	TIMER2_PORT	0x42
+#define	TIMER_MODE_PORT	0x43
+
+/* Meaning of the mode bits */
+#define	TIMER0_SEL	0x00
+#define	TIMER1_SEL	0x40
+#define	TIMER2_SEL	0x80
+#define	READBACK_SEL	0xC0
+
+#define	LATCH_COUNT	0x00
+#define	LOBYTE_ACCESS	0x10
+#define	HIBYTE_ACCESS	0x20
+#define	WORD_ACCESS	0x30
+
+#define	MODE0		0x00
+#define	MODE1		0x02
+#define	MODE2		0x04
+#define	MODE3		0x06
+#define	MODE4		0x08
+#define	MODE5		0x0A
+
+#define	BINARY_COUNT	0x00
+#define	BCD_COUNT	0x01
+
+/* Timers tick over at this rate */
+#define CLOCK_TICK_RATE	1193180U
+#define	TICKS_PER_MS	(CLOCK_TICK_RATE/1000)
+
+/* Parallel Peripheral Controller Port B */
+#define	PPC_PORTB	0x61
+
+/* Meaning of the port bits */
+#define	PPCB_T2OUT	0x20	/* Bit 5 */
+#define	PPCB_SPKR	0x02	/* Bit 1 */
+#define	PPCB_T2GATE	0x01	/* Bit 0 */
+
+/*
+extern void setup_timers(void);
+extern void ndelay(unsigned int nsecs);
+extern void udelay(unsigned int usecs);
+extern void mdelay(unsigned int msecs);
+extern unsigned long currticks(void);
+extern unsigned long get_timer_freq(void);
+*/
+#define TICKS_PER_SEC 1000
+
+#endif	/* TIMER_H */
diff -Nur grub2-lb.old/disk/i386/linuxbios/__udivdi3.c grub2-lb/disk/i386/linuxbios/__udivdi3.c
--- grub2-lb.old/disk/i386/linuxbios/__udivdi3.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/__udivdi3.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,13 @@
+/*
+ * arch/i386/libgcc/__divdi3.c
+ */
+
+#include <stdint.h>
+#include <stddef.h>
+
+extern uint64_t __udivmoddi4(uint64_t num, uint64_t den, uint64_t *rem);
+
+uint64_t __udivdi3(uint64_t num, uint64_t den)
+{
+  return __udivmoddi4(num, den, NULL);
+}
diff -Nur grub2-lb.old/disk/i386/linuxbios/__udivmoddi4.c grub2-lb/disk/i386/linuxbios/__udivmoddi4.c
--- grub2-lb.old/disk/i386/linuxbios/__udivmoddi4.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/__udivmoddi4.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,31 @@
+#include <grub/types.h>
+
+
+grub_uint64_t __udivmoddi4(grub_uint64_t num, grub_uint64_t den, grub_uint64_t *rem_p)
+{
+  grub_uint64_t quot = 0, qbit = 1;
+
+  if ( den == 0 ) {
+    return 0;			/* If trap returns... */
+  }
+
+  /* Left-justify denominator and count shift */
+  while ( (grub_int64_t)den >= 0 ) {
+    den <<= 1;
+    qbit <<= 1;
+  }
+
+  while ( qbit ) {
+    if ( den <= num ) {
+      num -= den;
+      quot += qbit;
+    }
+    den >>= 1;
+    qbit >>= 1;
+  }
+
+  if ( rem_p )
+    *rem_p = num;
+
+  return quot;
+}
diff -Nur grub2-lb.old/disk/i386/linuxbios/__umoddi3.c grub2-lb/disk/i386/linuxbios/__umoddi3.c
--- grub2-lb.old/disk/i386/linuxbios/__umoddi3.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/disk/i386/linuxbios/__umoddi3.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,16 @@
+/*
+ * arch/i386/libgcc/__umoddi3.c
+ */
+
+#include <stdint.h>
+#include <stddef.h>
+
+extern uint64_t __udivmoddi4(uint64_t num, uint64_t den, uint64_t *rem);
+
+uint64_t __umoddi3(uint64_t num, uint64_t den)
+{
+  uint64_t v;
+
+  (void) __udivmoddi4(num, den, &v);
+  return v;
+}
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/console.h grub2-lb/include/grub/i386/linuxbios/console.h
--- grub2-lb.old/include/grub/i386/linuxbios/console.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/console.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2005  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef GRUB_CONSOLE_MACHINE_HEADER
+#define GRUB_CONSOLE_MACHINE_HEADER	1
+
+/* Define scan codes.  */
+#define GRUB_CONSOLE_KEY_LEFT		0x4B00
+#define GRUB_CONSOLE_KEY_RIGHT		0x4D00
+#define GRUB_CONSOLE_KEY_UP		0x4800
+#define GRUB_CONSOLE_KEY_DOWN		0x5000
+#define GRUB_CONSOLE_KEY_IC		0x5200
+#define GRUB_CONSOLE_KEY_DC		0x5300
+#define GRUB_CONSOLE_KEY_BACKSPACE	0x0008
+#define GRUB_CONSOLE_KEY_HOME		0x4700
+#define GRUB_CONSOLE_KEY_END		0x4F00
+#define GRUB_CONSOLE_KEY_NPAGE		0x4900
+#define GRUB_CONSOLE_KEY_PPAGE		0x5100
+
+#ifndef ASM_FILE
+
+#include <grub/types.h>
+#include <grub/symbol.h>
+
+/* These are global to share code between C and asm.  */
+extern grub_uint8_t grub_console_cur_color;
+void grub_console_real_putchar (int c);
+int EXPORT_FUNC(grub_console_checkkey) (void);
+int EXPORT_FUNC(grub_console_getkey) (void);
+grub_uint16_t grub_console_getxy (void);
+void grub_console_gotoxy (grub_uint8_t x, grub_uint8_t y);
+void grub_console_cls (void);
+void grub_console_setcursor (int on);
+
+/* Initialize the console system.  */
+void grub_console_init (void);
+
+/* Finish the console system.  */
+void grub_console_fini (void);
+
+#endif
+
+#endif /* ! GRUB_CONSOLE_MACHINE_HEADER */
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/init.h grub2-lb/include/grub/i386/linuxbios/init.h
--- grub2-lb.old/include/grub/i386/linuxbios/init.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/init.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2004,2005,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_INIT_MACHINE_HEADER
+#define GRUB_INIT_MACHINE_HEADER	1
+
+#include <grub/types.h>
+#include <grub/symbol.h>
+
+/* FIXME: Should these be declared in memory.h?  */
+extern grub_size_t EXPORT_VAR(grub_lower_mem);
+extern grub_size_t EXPORT_VAR(grub_upper_mem);
+
+extern grub_addr_t EXPORT_VAR(grub_os_area_addr);
+extern grub_size_t EXPORT_VAR(grub_os_area_size);
+
+/* Get the memory size in KB. If EXTENDED is zero, return conventional
+   memory, otherwise return extended memory.  */
+grub_uint16_t grub_get_memsize (int extended);
+
+/* Get a packed EISA memory map. Lower 16 bits are between 1MB and 16MB
+   in 1KB parts, and upper 16 bits are above 16MB in 64KB parts.  */
+grub_uint32_t grub_get_eisa_mmap (void);
+
+struct grub_machine_mmap_entry
+{
+  grub_uint32_t size;
+  grub_uint64_t addr;
+  grub_uint64_t len;
+  grub_uint32_t type;
+};
+
+/* Get a memory map entry. Return next continuation value. Zero means
+   the end.  */
+grub_uint32_t grub_get_mmap_entry (struct grub_machine_mmap_entry *entry,
+				   grub_uint32_t cont);
+
+/* Turn on/off Gate A20.  */
+void grub_gate_a20 (int on);
+
+#endif /* ! GRUB_INIT_MACHINE_HEADER */
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/kernel.h grub2-lb/include/grub/i386/linuxbios/kernel.h
--- grub2-lb.old/include/grub/i386/linuxbios/kernel.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/kernel.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2003  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef KERNEL_MACHINE_HEADER
+#define KERNEL_MACHINE_HEADER	1
+
+#ifndef ASM_FILE
+
+#include <grub/types.h>
+
+#define GRUB_MOD_ALIGN 0x1000
+
+/* The DOS partition number of the installed partition.  */
+extern grub_int32_t grub_install_dos_part;
+
+/* The BSD partition number of the installed partition.  */
+extern grub_int32_t grub_install_bsd_part;
+
+/* The prefix which points to the directory where GRUB modules and its
+   configuration file are located.  */
+extern char grub_prefix[];
+
+/* The boot BIOS drive number.  */
+extern grub_int32_t grub_boot_drive;
+
+/* The end address of the kernel.  */
+extern grub_addr_t grub_end_addr;
+
+#endif /* ! ASM_FILE */
+
+#endif /* ! KERNEL_MACHINE_HEADER */
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/loader.h grub2-lb/include/grub/i386/linuxbios/loader.h
--- grub2-lb.old/include/grub/i386/linuxbios/loader.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/loader.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2003,2004,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_LOADER_MACHINE_HEADER
+#define GRUB_LOADER_MACHINE_HEADER	1
+
+#include <grub/types.h>
+#include <grub/symbol.h>
+#include <grub/multiboot.h>
+
+extern grub_addr_t EXPORT_VAR(grub_os_area_addr);
+extern grub_size_t EXPORT_VAR(grub_os_area_size);
+
+/* The asm part of the multiboot loader.  */
+void EXPORT_FUNC(grub_multiboot_real_boot) (grub_addr_t entry, 
+					    struct grub_multiboot_info *mbi) 
+     __attribute__ ((noreturn));
+void EXPORT_FUNC(grub_multiboot2_real_boot) (grub_addr_t entry,
+                                             struct grub_multiboot_info *mbi)
+     __attribute__ ((noreturn));
+
+/* It is necessary to export these functions, because normal mode commands
+   reuse rescue mode commands.  */
+void grub_rescue_cmd_linux (int argc, char *argv[]);
+void grub_rescue_cmd_initrd (int argc, char *argv[]);
+
+#endif /* ! GRUB_LOADER_MACHINE_HEADER */
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/serial.h grub2-lb/include/grub/i386/linuxbios/serial.h
--- grub2-lb.old/include/grub/i386/linuxbios/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/serial.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,67 @@
+/* serial.h - serial device interface */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2000,2001,2002,2005,2007  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_SERIAL_MACHINE_HEADER
+#define GRUB_SERIAL_MACHINE_HEADER	1
+
+/* Macros.  */
+
+/* The offsets of UART registers.  */
+#define UART_TX		0
+#define UART_RX		0
+#define UART_DLL	0
+#define UART_IER	1
+#define UART_DLH	1
+#define UART_IIR	2
+#define UART_FCR	2
+#define UART_LCR	3
+#define UART_MCR	4
+#define UART_LSR	5
+#define UART_MSR	6
+#define UART_SR		7
+
+/* For LSR bits.  */
+#define UART_DATA_READY		0x01
+#define UART_EMPTY_TRANSMITTER	0x20
+
+/* The type of parity.  */
+#define UART_NO_PARITY		0x00
+#define UART_ODD_PARITY		0x08
+#define UART_EVEN_PARITY	0x18
+
+/* The type of word length.  */
+#define UART_5BITS_WORD	0x00
+#define UART_6BITS_WORD	0x01
+#define UART_7BITS_WORD	0x02
+#define UART_8BITS_WORD	0x03
+
+/* The type of the length of stop bit.  */
+#define UART_1_STOP_BIT		0x00
+#define UART_2_STOP_BITS	0x04
+
+/* the switch of DLAB.  */
+#define UART_DLAB	0x80
+
+/* Enable the FIFO.  */
+#define UART_ENABLE_FIFO	0xC7
+
+/* Turn on DTR, RTS, and OUT2.  */
+#define UART_ENABLE_MODEM	0x0B
+
+#endif /* ! GRUB_SERIAL_MACHINE_HEADER */
diff -Nur grub2-lb.old/include/grub/i386/linuxbios/time.h grub2-lb/include/grub/i386/linuxbios/time.h
--- grub2-lb.old/include/grub/i386/linuxbios/time.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/grub/i386/linuxbios/time.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2003,2004,2005  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef KERNEL_TIME_HEADER
+#define KERNEL_TIME_HEADER	1
+
+#include <grub/symbol.h>
+
+#define GRUB_TICKS_PER_SECOND	18
+
+/* Return the real time in ticks.  */
+grub_uint32_t EXPORT_FUNC (grub_get_rtc) (void);
+
+#endif /* ! KERNEL_TIME_HEADER */
diff -Nur grub2-lb.old/include/stdint.h grub2-lb/include/stdint.h
--- grub2-lb.old/include/stdint.h	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/include/stdint.h	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef GRUB_STDINT_HEADER
+#define GRUB_STDINT_HEADER
+
+#include <grub/types.h>
+
+#define __WORDSIZE 32
+typedef grub_uint32_t uint32_t;
+typedef grub_uint64_t uint64_t;
+
+#endif
diff -Nur grub2-lb.old/kern/i386/linuxbios/cmain.c grub2-lb/kern/i386/linuxbios/cmain.c
--- grub2-lb.old/kern/i386/linuxbios/cmain.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/kern/i386/linuxbios/cmain.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,128 @@
+#include <grub/env.h>
+#include <grub/mm.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/machine/console.h>
+#include <grub/machine/kernel.h>
+#include <grub/machine/init.h>
+#include <grub/machine/loader.h>
+#include <multiboot.h>
+
+char grub_prefix[50]="(rom)\0";
+extern char* _end;
+
+grub_size_t grub_lower_mem, grub_upper_mem;
+grub_addr_t grub_os_area_addr;
+grub_size_t grub_os_area_size;
+
+void
+grub_machine_init (void)
+{
+  grub_int32_t* lbtable = (void*)0x500;
+
+  grub_console_init();
+  if (*lbtable != 'OIBL')
+  {
+    grub_fatal("LinuxBIOSv3 table not found!");
+  }
+  lbtable += (lbtable[1]/sizeof(lbtable));
+  for (;lbtable[1] != 0; lbtable += (lbtable[1]/sizeof(lbtable)))
+  {
+    if (*lbtable==1)
+    {
+      struct mem_range
+      {
+        grub_int32_t start;
+        grub_int32_t start_hi;
+        grub_int32_t size;
+        grub_int32_t size_hi;
+        grub_int32_t type;
+      };
+      struct mem_range* mem;
+      grub_int32_t maxmem = 0;
+      grub_int32_t usablemem = 0;
+      grub_os_area_addr = 0;
+      grub_os_area_size = 0;
+      for (mem = (struct mem_range*)&lbtable[2]; mem < lbtable+lbtable[1]/sizeof(lbtable); mem++)
+      {
+        if ((mem->start_hi!=0) || (mem->size_hi!=0)) {
+	  grub_fatal("memory range >32bit given in LBv3's memory table");
+	}
+	if (mem->start + mem->size > maxmem) maxmem = mem->start + mem->size;
+	usablemem += mem->size;
+      }
+      for (mem = (struct mem_range*)&lbtable[2]; mem < lbtable+lbtable[1]/sizeof(lbtable); mem++)
+      {
+	if ((mem->type == 1) && (mem->size > 0)) {
+	  if (mem->start + mem->size > 0x100000) {
+	    if (mem->start < 0x100000) {
+	      mem->size -= 0x100000 - mem->start;
+	      mem->start = 0x100000;
+	    }
+	    if (mem->start = 0x100000) {
+	      grub_os_area_addr = 0x100000;
+	      grub_os_area_size = mem->size / 4;
+	      mem->size = grub_os_area_size * 3;
+	      mem->start += grub_os_area_size;
+	    }
+	    grub_mm_init_region((void*)mem->start,mem->size);
+	  }
+	}
+      }
+      grub_lower_mem = 0x100000;
+      grub_upper_mem = maxmem - grub_lower_mem;
+   }
+  }
+}
+
+void
+grub_machine_fini (void)
+{
+grub_console_fini();
+}
+
+void
+grub_machine_set_prefix (void)
+{
+  grub_env_set ("prefix", grub_prefix);
+}
+
+grub_addr_t
+grub_arch_modules_addr (void)
+{
+  return ALIGN_UP(&_end, GRUB_MOD_ALIGN);
+}
+
+void
+grub_arch_sync_caches (void)
+{}
+
+void
+grub_get_rtc (void)
+{}
+
+void
+grub_exit (void)
+{}
+
+void
+grub_multiboot2_real_boot(grub_addr_t entry, struct grub_multiboot_info *mbi)
+{
+  void (*f)() = entry;
+  f();
+  grub_fatal("the client is not supposed to come back!");
+}
+
+void
+grub_multiboot_real_boot(grub_addr_t entry, struct grub_multiboot_info *mbi)
+{
+  grub_dl_unload_all();
+  
+  asm(
+    "movl %0, %%ebx;"
+    "movl %2, %%eax;"
+    "jmp *%1" :
+    : "r"(mbi), "r"(entry), "i"(MULTIBOOT_MAGIC2)
+    : "eax", "ebx");
+  grub_fatal("the client is not supposed to come back!");
+}
diff -Nur grub2-lb.old/kern/i386/linuxbios/console.c grub2-lb/kern/i386/linuxbios/console.c
--- grub2-lb.old/kern/i386/linuxbios/console.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/kern/i386/linuxbios/console.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,357 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2003,2005  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <grub/machine/console.h>
+#include <grub/term.h>
+#include <grub/types.h>
+
+grub_uint8_t grub_console_cur_color = 0x7;
+static grub_uint8_t grub_console_standard_color = 0x7;
+static grub_uint8_t grub_console_normal_color = 0x7;
+static grub_uint8_t grub_console_highlight_color = 0x70;
+
+int consolex,consoley;
+char* videomem=(char*)0xb8000;
+
+/* Read a byte from a port.  */
+static inline unsigned char
+inb (unsigned short port)
+{
+  unsigned char value;
+
+  asm volatile ("inb    %w1, %0" : "=a" (value) : "Nd" (port));
+
+  return value;
+}
+
+/* Write a byte to a port.  */
+static inline void
+outb (unsigned short port, unsigned char value)
+{
+  asm volatile ("outb   %b0, %w1" : : "a" (value), "Nd" (port));
+}
+
+static int normalkeycodemap[128] = {
+/*0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f*/
+-1,'\e','1','2','3','4','5','6','7','8','9','0','-','=','\b','\t',
+'q','w','e','r','t','y','u','i','o','p','[',']','\n',-1,'a','s',
+'d','f','g','h','j','k','l',';','\'',-1,-1,'\\','z','x','c','v',
+'b','n','m',',','.','/', -1, -1, -1,' ', -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static int shiftedkeycodemap[128] = {
+/*0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f*/
+-1,'\e','!','@','#','$','%','^','&','*','(',')','_','+','\b','\t',
+'Q','W','E','R','T','Y','U','I','O','P','{','}','\n',-1,'A','S',
+'D','F','G','H','J','K','L',':','"', -1, -1,'|','Z','X','C','V',
+'B','N','M','<','>','?', -1, -1, -1,' ', -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static int ctrlmap[128] = {
+/*0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f*/
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ 17, 23,  5, 18, 20, 25, 21,  9, 15, 16, -1, -1, -1, -1,  1, 19,
+  4,  6,  7,  8, 10, 11, 12, -1, -1, -1, -1, -1, 26, 24,  3, 22,
+  2, 14, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static int* keycodemap=normalkeycodemap;
+static int shiftkey=0;
+static int ctrlkey=0;
+
+static int wait_for_keycode() {
+ while ((inb(0x64)&1)==0) ;
+ return inb(0x60);
+}
+
+static int getkey() {
+  int keycode=inb(0x60);
+  switch (keycode)
+  {
+    case 0x2a:
+    case 0x36:
+      keycodemap=shiftedkeycodemap;
+      shiftkey++;
+      break;
+    case 0xaa:
+    case 0xb6:
+      shiftkey--;
+      if (shiftkey==0) keycodemap=normalkeycodemap;
+      break;
+    case 0x1d:
+      ctrlkey++;
+      break;
+    case 0x9d:
+      ctrlkey--;
+      break;
+    default:
+      break;
+  }
+  if (keycode == 0xe0)
+  {
+    int key = wait_for_keycode();
+    switch (key)
+    {
+      case 0x1d:
+        ctrlkey++;
+	break;
+      case 0x9d:
+        ctrlkey--;
+      /* cases below this comment are adapted using i386/pc/startup.S's
+         translation_table */
+      case 0x48:
+        return 16;
+      case 0x4b:
+        return 2;
+      case 0x4d:
+        return 6;
+      case 0x50:
+        return 14;
+      case 0x47:
+        return 1;
+      case 0x4f:
+        return 5;
+      case 0x49:
+        return 7;
+      case 0x51:
+        return 3;
+      case 0x53:
+        return 4;
+      default:
+        break;
+    }
+  }
+  if (keycode >= 0x80)
+  {
+    /* scancode set 1 encodes break as +0x80 */
+    return -1;
+  }
+  if (ctrlkey>0)
+  {
+    return ctrlmap[keycode];
+  }
+  return keycodemap[keycode];
+}
+
+int
+grub_console_checkkey (void)
+{
+ if ((inb(0x64)&1)==0) return -1;
+ return getkey();
+}
+
+int grub_console_getkey(void) {
+  int key;
+  while ((key=grub_console_checkkey())==-1) {}
+  return key;
+}
+
+grub_uint16_t grub_console_getxy (void) {
+  return (consolex<<8)+consoley;
+}
+
+void grub_console_gotoxy (grub_uint8_t x, grub_uint8_t y) {
+  consolex=x;
+  consoley=y;
+}
+
+void grub_console_cls (void) {
+  int i;
+  for (i=0;i<80*25*2;i+=2) {
+    videomem[i]=32;
+    videomem[i+1]=grub_console_cur_color;
+  }
+}
+
+void grub_console_setcursor (int on) {
+}
+
+static grub_uint32_t
+map_char (grub_uint32_t c)
+{
+  if (c > 0x7f)
+    {
+      /* Map some unicode characters to the VGA font, if possible.  */
+      switch (c)
+	{
+	case 0x2190:	/* left arrow */
+	  c = 0x1b;
+	  break;
+	case 0x2191:	/* up arrow */
+	  c = 0x18;
+	  break;
+	case 0x2192:	/* right arrow */
+	  c = 0x1a;
+	  break;
+	case 0x2193:	/* down arrow */
+	  c = 0x19;
+	  break;
+	case 0x2501:	/* horizontal line */
+	  c = 0xc4;
+	  break;
+	case 0x2503:	/* vertical line */
+	  c = 0xb3;
+	  break;
+	case 0x250F:	/* upper-left corner */
+	  c = 0xda;
+	  break;
+	case 0x2513:	/* upper-right corner */
+	  c = 0xbf;
+	  break;
+	case 0x2517:	/* lower-left corner */
+	  c = 0xc0;
+	  break;
+	case 0x251B:	/* lower-right corner */
+	  c = 0xd9;
+	  break;
+
+	default:
+	  c = '?';
+	  break;
+	}
+    }
+
+  return c;
+}
+
+static void
+grub_console_putchar (grub_uint32_t c)
+{
+  grub_uint8_t ch=map_char(c);
+  if (ch>=32) {
+	  videomem[(consoley*80+consolex)*2]=ch;
+	  videomem[(consoley*80+consolex)*2+1]=grub_console_cur_color;
+	  consolex++;
+  } else if (ch=='\n') {
+	consolex=0;
+	consoley++;
+  } else if (ch=='\t') {
+	consolex=consolex-(consolex%8)+8;
+  } else if (ch=='\b') {
+	consolex--;
+	if (consolex==-1) consolex=0;
+  }
+  if (consolex>=80) {
+    consoley++;
+    consolex-=80;
+  }
+  if (consoley==25) {
+    int i;
+    consoley--;
+    for (i=0;i<80*24*2;i++) {
+      videomem[i]=videomem[i+80*2];
+    }
+    for (i=80*24*2;i<80*25*2;i+=2) {
+      videomem[i]=' ';
+      videomem[i+1]=grub_console_cur_color;
+    }
+  }
+}
+
+static grub_ssize_t
+grub_console_getcharwidth (grub_uint32_t c __attribute__ ((unused)))
+{
+  /* For now, every printable character has the width 1.  */
+  return 1;
+}
+
+static grub_uint16_t
+grub_console_getwh (void)
+{
+  return (80 << 8) | 25;
+}
+
+static void
+grub_console_setcolorstate (grub_term_color_state state)
+{
+  switch (state) {
+    case GRUB_TERM_COLOR_STANDARD:
+      grub_console_cur_color = grub_console_standard_color;
+      break;
+    case GRUB_TERM_COLOR_NORMAL:
+      grub_console_cur_color = grub_console_normal_color;
+      break;
+    case GRUB_TERM_COLOR_HIGHLIGHT:
+      grub_console_cur_color = grub_console_highlight_color;
+      break;
+    default:
+      break;
+  }
+}
+
+static void
+grub_console_setcolor (grub_uint8_t normal_color, grub_uint8_t highlight_color)
+{
+  grub_console_normal_color = normal_color;
+  grub_console_highlight_color = highlight_color;
+}
+
+static struct grub_term grub_console_term =
+  {
+    .name = "console",
+    .init = 0,
+    .fini = 0,
+    .putchar = grub_console_putchar,
+    .getcharwidth = grub_console_getcharwidth,
+    .checkkey = grub_console_checkkey,
+    .getkey = grub_console_getkey,
+    .getwh = grub_console_getwh,
+    .getxy = grub_console_getxy,
+    .gotoxy = grub_console_gotoxy,
+    .cls = grub_console_cls,
+    .setcolorstate = grub_console_setcolorstate,
+    .setcolor = grub_console_setcolor,
+    .setcursor = grub_console_setcursor,
+    .flags = 0,
+    .next = 0
+  };
+
+void
+grub_console_init (void)
+{
+  int tmp;
+  grub_term_register (&grub_console_term);
+  grub_term_set_current (&grub_console_term);
+  while (grub_console_checkkey()!=-1) {
+    inb(0x60);
+  }
+  outb(0x64,0x20);
+  tmp=inb(0x60)&~0x40;
+  outb(0x64,0x60);
+  outb(tmp,0x60);
+}
+
+void
+grub_console_fini (void)
+{
+  grub_term_set_current (&grub_console_term);
+  grub_term_unregister (&grub_console_term);
+}
diff -Nur grub2-lb.old/kern/i386/linuxbios/crt0.S grub2-lb/kern/i386/linuxbios/crt0.S
--- grub2-lb.old/kern/i386/linuxbios/crt0.S	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/kern/i386/linuxbios/crt0.S	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,68 @@
+/* boot.S - bootstrap the kernel */
+/* Copyright (C) 1999  Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#define ASM	1
+#define STACK_SIZE 0x10000
+	
+	.text
+
+	.code32
+	.globl	start, _start
+
+	/* This entry is not used actually.  */
+start:
+_start:
+	jmp	multiboot_entry
+
+	/* Align 32 bits boundary.  */
+	.align	4
+	
+	/* Multiboot header.  */
+multiboot_header:
+	/* magic */
+	.long   0x1BADB002
+	/* flags */
+	.long   (1 << 16)
+	/* checksum */
+	.long   -0x1BADB002 - (1 << 16)
+	/* header_addr */
+	.long	multiboot_header
+	/* load_addr */
+	.long	_start
+	/* load_end_addr */
+	.long	_edata
+	/* bss_end_addr */
+	.long	_end
+	/* entry_addr */
+	.long	multiboot_entry
+
+multiboot_entry:
+	/* Initialize the stack pointer.  */
+	movl	$(stack + STACK_SIZE), %esp
+
+	/* Reset EFLAGS.  */
+	pushl	$0
+	popf
+
+	/* Now enter the C main function...  */
+	call	grub_main
+
+loop:	hlt
+	jmp	loop
+
+	/* Our stack area.  */
+	.comm	stack, STACK_SIZE
diff -Nur grub2-lb.old/util/i386/linuxbios/grub-mkimage.c grub2-lb/util/i386/linuxbios/grub-mkimage.c
--- grub2-lb.old/util/i386/linuxbios/grub-mkimage.c	1970-01-01 01:00:00.000000000 +0100
+++ grub2-lb/util/i386/linuxbios/grub-mkimage.c	2007-10-04 14:38:15.000000000 +0200
@@ -0,0 +1,279 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2004,2005,2006,2007  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <string.h>
+#include <grub/elf.h>
+#include <grub/misc.h>
+#include <grub/util/misc.h>
+#include <grub/util/resolve.h>
+#include <grub/kernel.h>
+#include <grub/machine/kernel.h>
+
+void
+load_modules (grub_addr_t modbase, Elf32_Phdr *phdr, const char *dir,
+	      char *mods[], FILE *out)
+{
+  char *module_img;
+  struct grub_util_path_list *path_list;
+  struct grub_util_path_list *p;
+  struct grub_module_info *modinfo;
+  size_t offset;
+  size_t total_module_size;
+
+  path_list = grub_util_resolve_dependencies (dir, "moddep.lst", mods);
+
+  offset = sizeof (struct grub_module_info);
+  total_module_size = sizeof (struct grub_module_info);
+  for (p = path_list; p; p = p->next)
+    {
+      total_module_size += (grub_util_get_image_size (p->name)
+	  + sizeof (struct grub_module_header));
+    }
+
+  grub_util_info ("the total module size is 0x%x", total_module_size);
+
+  module_img = xmalloc (total_module_size);
+  modinfo = (struct grub_module_info *) module_img;
+  modinfo->magic = grub_cpu_to_le32 (GRUB_MODULE_MAGIC);
+  modinfo->offset = grub_cpu_to_le32 (sizeof (struct grub_module_info));
+  modinfo->size = grub_cpu_to_le32 (total_module_size);
+
+  /* Load all the modules, with headers, into module_img.  */
+  for (p = path_list; p; p = p->next)
+    {
+      struct grub_module_header *header;
+      size_t mod_size;
+
+      grub_util_info ("adding module %s", p->name);
+
+      mod_size = grub_util_get_image_size (p->name);
+
+      header = (struct grub_module_header *) (module_img + offset);
+      header->offset = grub_cpu_to_le32 (sizeof (*header));
+      header->size = grub_cpu_to_le32 (mod_size + sizeof (*header));
+
+      grub_util_load_image (p->name, module_img + offset + sizeof (*header));
+
+      offset += sizeof (*header) + mod_size;
+    }
+
+  /* Write the module data to the new segment.  */
+  grub_util_write_image_at (module_img, total_module_size,
+			    grub_cpu_to_le32 (phdr->p_offset), out);
+
+  /* Fill in the rest of the segment header.  */
+  phdr->p_type = grub_cpu_to_le32 (PT_LOAD);
+  phdr->p_flags = grub_cpu_to_le32 (PF_R | PF_W | PF_X);
+  phdr->p_align = grub_cpu_to_le32 (0x1000);
+  phdr->p_vaddr = grub_cpu_to_le32 (modbase);
+  phdr->p_paddr = grub_cpu_to_le32 (modbase);
+  phdr->p_filesz = grub_cpu_to_le32 (total_module_size);
+  phdr->p_memsz = grub_cpu_to_le32 (total_module_size);
+}
+
+void
+add_segments (char *dir, FILE *out, char *mods[])
+{
+  Elf32_Ehdr ehdr;
+  Elf32_Phdr *phdrs = NULL;
+  Elf32_Phdr *phdr;
+  FILE *in;
+  char *kernel_path;
+  grub_addr_t grub_end = 0;
+  off_t phdroff;
+  int i;
+
+  /* Read ELF header.  */
+  kernel_path = grub_util_get_path (dir, "kernel.elf");
+  in = fopen (kernel_path, "rb");
+  if (! in)
+    grub_util_error ("cannot open %s", kernel_path);
+
+  grub_util_read_at (&ehdr, sizeof (ehdr), 0, in);
+  
+  phdrs = xmalloc (grub_le_to_cpu16 (ehdr.e_phentsize)
+		   * (grub_le_to_cpu16 (ehdr.e_phnum) + 2));
+  /* Copy all existing segments.  */
+  grub_util_info ("%u segments", grub_le_to_cpu16 (ehdr.e_phnum));
+  for (i = 0; i < grub_le_to_cpu16 (ehdr.e_phnum); i++)
+    {
+      char *segment_img;
+      grub_size_t segment_end;
+
+      phdr = phdrs + i;
+
+      /* Read segment header.  */
+      grub_util_read_at (phdr, sizeof (Elf32_Phdr),
+			 (grub_le_to_cpu32 (ehdr.e_phoff)
+			  + (i * grub_le_to_cpu16 (ehdr.e_phentsize))),
+			 in);
+      grub_util_info ("copying segment %d, type %d", i,
+		      grub_le_to_cpu32 (phdr->p_type));
+
+      /* Locate _end.  */
+      segment_end = grub_le_to_cpu32 (phdr->p_paddr)
+		    + grub_le_to_cpu32 (phdr->p_memsz);
+      grub_util_info ("segment %u end 0x%lx", i, segment_end);
+      if (segment_end > grub_end)
+	grub_end = segment_end;
+
+      /* Read segment data and write it to new file.  */
+      segment_img = xmalloc (grub_le_to_cpu32 (phdr->p_filesz));
+  
+      grub_util_read_at (segment_img, grub_le_to_cpu32 (phdr->p_filesz),
+			 grub_le_to_cpu32 (phdr->p_offset), in);
+      grub_util_write_image_at (segment_img, grub_le_to_cpu32 (phdr->p_filesz),
+				grub_le_to_cpu32 (phdr->p_offset), out);
+
+      free (segment_img);
+    }
+
+  if (mods[0] != NULL)
+    {
+      grub_addr_t modbase;
+
+      /* Place modules just after grub segment.  */
+      modbase = ALIGN_UP(grub_end, GRUB_MOD_ALIGN);
+
+      /* Construct new segment header for modules.  */
+      phdr = phdrs + grub_le_to_cpu16 (ehdr.e_phnum);
+      ehdr.e_phnum = grub_cpu_to_le16 (grub_le_to_cpu16 (ehdr.e_phnum) + 1);
+
+      /* Fill in p_offset so the callees know where to write.  */
+      phdr->p_offset = grub_cpu_to_le32 (ALIGN_UP (grub_util_get_fp_size (out),
+						   sizeof (long)));
+
+      load_modules (modbase, phdr, dir, mods, out);
+    }
+
+  /* Don't bother preserving the section headers.  */
+  ehdr.e_shoff = 0;
+  ehdr.e_shnum = 0;
+  ehdr.e_shstrndx = 0;
+
+  /* Append entire segment table to the file.  */
+  phdroff = ALIGN_UP (grub_util_get_fp_size (out), sizeof (long));
+  grub_util_write_image_at (phdrs, grub_le_to_cpu16 (ehdr.e_phentsize)
+			    * grub_le_to_cpu16 (ehdr.e_phnum), phdroff,
+			    out);
+
+  /* Write ELF header.  */
+  ehdr.e_phoff = grub_cpu_to_le32 (phdroff);
+  grub_util_write_image_at (&ehdr, sizeof (ehdr), 0, out);
+
+  free (phdrs);
+  free (kernel_path);
+}
+
+static struct option options[] =
+  {
+    {"directory", required_argument, 0, 'd'},
+    {"output", required_argument, 0, 'o'},
+    {"help", no_argument, 0, 'h'},
+    {"version", no_argument, 0, 'V'},
+    {"verbose", no_argument, 0, 'v'},
+    { 0, 0, 0, 0 },
+  };
+
+static void
+usage (int status)
+{
+  if (status)
+    fprintf (stderr, "Try ``grub-mkimage --help'' for more information.\n");
+  else
+    printf ("\
+Usage: grub-mkimage -o FILE [OPTION]... [MODULES]\n\
+\n\
+Make a bootable image of GRUB.\n\
+\n\
+-d, --directory=DIR     use images and modules under DIR [default=%s]\n\
+-o, --output=FILE       output a generated image to FILE\n\
+-h, --help              display this message and exit\n\
+-V, --version           print version information and exit\n\
+-v, --verbose           print verbose messages\n\
+\n\
+Report bugs to <%s>.\n\
+", GRUB_LIBDIR, PACKAGE_BUGREPORT);
+
+  exit (status);
+}
+
+int
+main (int argc, char *argv[])
+{
+  FILE *fp;
+  char *output = NULL;
+  char *dir = NULL;
+
+  progname = "grub-mkimage";
+
+  while (1)
+    {
+      int c = getopt_long (argc, argv, "d:o:hVvn", options, 0);
+      if (c == -1)
+	break;
+
+      switch (c)
+	{
+	  case 'd':
+	    if (dir)
+	      free (dir);
+	    dir = xstrdup (optarg);
+	    break;
+	  case 'h':
+	    usage (0);
+	    break;
+	  case 'o':
+	    if (output)
+	      free (output);
+	    output = xstrdup (optarg);
+	    break;
+	  case 'V':
+	    printf ("grub-mkimage (%s) %s\n", PACKAGE_NAME, PACKAGE_VERSION);
+	    return 0;
+	  case 'v':
+	    verbosity++;
+	    break;
+	  default:
+	    usage (1);
+	    break;
+	}
+  }
+
+  if (!output)
+    usage (1);
+
+  fp = fopen (output, "wb");
+  if (! fp)
+    grub_util_error ("cannot open %s", output);
+
+  add_segments (dir ? : GRUB_LIBDIR, fp, argv + optind);
+
+  fclose (fp);
+
+  return 0;
+}
