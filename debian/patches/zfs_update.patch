
Revisions:

3340: ZFS zlib support
3474: Fix 2G limit on ZFS
3486: ZFS fixes

--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -51,6 +51,7 @@
 #include <grub/zfs/sa_impl.h>
 #include <grub/zfs/dsl_dir.h>
 #include <grub/zfs/dsl_dataset.h>
+#include <grub/deflate.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -163,13 +164,30 @@
   grub_disk_addr_t vdev_phys_sector;
 };
 
+static grub_err_t 
+zlib_decompress (void *s, void *d,
+		 grub_size_t slen, grub_size_t dlen)
+{
+  if (grub_zlib_decompress (s, slen, 0, d, dlen) < 0)
+    return grub_errno;
+  return GRUB_ERR_NONE;
+}
+
 static decomp_entry_t decomp_table[ZIO_COMPRESS_FUNCTIONS] = {
   {"inherit", NULL},		/* ZIO_COMPRESS_INHERIT */
   {"on", lzjb_decompress},	/* ZIO_COMPRESS_ON */
   {"off", NULL},		/* ZIO_COMPRESS_OFF */
   {"lzjb", lzjb_decompress},	/* ZIO_COMPRESS_LZJB */
   {"empty", NULL},		/* ZIO_COMPRESS_EMPTY */
-  {"gzip", NULL},		/* ZIO_COMPRESS_GZIP */
+  {"gzip-1", zlib_decompress},  /* ZIO_COMPRESS_GZIP1 */
+  {"gzip-2", zlib_decompress},  /* ZIO_COMPRESS_GZIP2 */
+  {"gzip-3", zlib_decompress},  /* ZIO_COMPRESS_GZIP3 */
+  {"gzip-4", zlib_decompress},  /* ZIO_COMPRESS_GZIP4 */
+  {"gzip-5", zlib_decompress},  /* ZIO_COMPRESS_GZIP5 */
+  {"gzip-6", zlib_decompress},  /* ZIO_COMPRESS_GZIP6 */
+  {"gzip-7", zlib_decompress},  /* ZIO_COMPRESS_GZIP7 */
+  {"gzip-8", zlib_decompress},  /* ZIO_COMPRESS_GZIP8 */
+  {"gzip-9", zlib_decompress},  /* ZIO_COMPRESS_GZIP9 */
 };
 
 static grub_err_t zio_read_data (blkptr_t * bp, grub_zfs_endian_t endian,
@@ -224,7 +242,7 @@
  */
 static grub_err_t
 zio_checksum_verify (zio_cksum_t zc, grub_uint32_t checksum,
-		     grub_zfs_endian_t endian, char *buf, int size)
+		     grub_zfs_endian_t endian, char *buf, grub_size_t size)
 {
   zio_eck_t *zec = (zio_eck_t *) (buf + size) - 1;
   zio_checksum_info_t *ci = &zio_checksum_table[checksum];
@@ -319,7 +337,7 @@
  *
  */
 static grub_err_t
-uberblock_verify (uberblock_phys_t * ub, int offset)
+uberblock_verify (uberblock_phys_t * ub, grub_uint64_t offset)
 {
   uberblock_t *uber = &ub->ubp_uberblock;
   grub_err_t err;
@@ -527,7 +545,7 @@
   *buf = NULL;
 
   checksum = (grub_zfs_to_cpu64((bp)->blk_prop, endian) >> 40) & 0xff;
-  comp = (grub_zfs_to_cpu64((bp)->blk_prop, endian)>>32) & 0x7;
+  comp = (grub_zfs_to_cpu64((bp)->blk_prop, endian)>>32) & 0xff;
   lsize = (BP_IS_HOLE(bp) ? 0 :
 	   (((grub_zfs_to_cpu64 ((bp)->blk_prop, endian) & 0xffff) + 1)
 	    << SPA_MINBLOCKSHIFT));
@@ -602,7 +620,8 @@
 dmu_read (dnode_end_t * dn, grub_uint64_t blkid, void **buf, 
 	  grub_zfs_endian_t *endian_out, struct grub_zfs_data *data)
 {
-  int idx, level;
+  int level;
+  grub_off_t idx;
   blkptr_t *bp_array = dn->dn.dn_blkptr;
   int epbs = dn->dn.dn_indblkshift - SPA_BLKPTRSHIFT;
   blkptr_t *bp;
@@ -922,7 +941,7 @@
 {
   zap_leaf_phys_t *l;
   void *l_in;
-  grub_uint64_t idx, blkid;
+  grub_uint64_t idx, idx2, blkid;
   grub_uint16_t chunk;
   int blksft = zfs_log2 (grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec, 
 					    zap_dnode->endian) << DNODE_SHIFT);
@@ -945,10 +964,16 @@
       grub_error (GRUB_ERR_BAD_FS, "ZAP leaf is too small");
       return 0;
     }
-  for (idx = 0; idx < zap->zap_ptrtbl.zt_numblks; idx++)
+  for (idx = 0; idx < (1ULL << zap->zap_ptrtbl.zt_shift); idx++)
     {
       blkid = ((grub_uint64_t *) zap)[idx + (1 << (blksft - 3 - 1))];
 
+      for (idx2 = 0; idx2 < idx; idx2++)
+	if (blkid == ((grub_uint64_t *) zap)[idx2 + (1 << (blksft - 3 - 1))])
+	  break;
+      if (idx2 != idx)
+	continue;
+
       err = dmu_read (zap_dnode, blkid, &l_in, &endian, data);
       l = l_in;
       if (err)
@@ -1074,7 +1099,7 @@
     return 0;
   block_type = grub_zfs_to_cpu64 (*((grub_uint64_t *) zapbuf), endian);
 
-  grub_dprintf ("zfs", "zap read\n");
+  grub_dprintf ("zfs", "zap iterate\n");
 
   if (block_type == ZBT_MICRO)
     {
@@ -1291,22 +1316,55 @@
 	break;
 
       *path = ch;
-#if 0
-      if (((grub_zfs_to_cpu64(((znode_phys_t *) DN_BONUS (&dnode_path->dn.dn))->zp_mode, dnode_path->dn.endian) >> 12) & 0xf) == 0xa && ch)
+      if (((grub_zfs_to_cpu64(((znode_phys_t *) DN_BONUS (&dnode_path->dn.dn))->zp_mode, dnode_path->dn.endian) >> 12) & 0xf) == 0xa)
 	{
+	  char *sym_value;
+	  grub_size_t avail_in_dnode;
+	  grub_size_t sym_sz;
+	  int free_symval = 0;
 	  char *oldpath = path, *oldpathbuf = path_buf;
-	  path = path_buf 
-	    = grub_malloc (sizeof (dnode_path->dn.dn.dn_bonus) 
-			   - sizeof (znode_phys_t) + grub_strlen (oldpath) + 1);
+	  sym_value = ((char *) DN_BONUS (&dnode_path->dn.dn) + sizeof (struct znode_phys));
+	  avail_in_dnode = (char *) (&dnode_path->dn + 1) - sym_value;
+
+	  sym_sz = grub_zfs_to_cpu64 (((znode_phys_t *) DN_BONUS (&dnode_path->dn.dn))->zp_size, dnode_path->dn.endian);
+
+	  if (sym_sz > avail_in_dnode - 8)
+	    {
+	      grub_size_t block;
+	      grub_size_t blksz;
+	      blksz = (grub_zfs_to_cpu16 (dnode_path->dn.dn.dn_datablkszsec, 
+					 dnode_path->dn.endian)
+		       << SPA_MINBLOCKSHIFT);
+
+	      sym_value = grub_malloc (sym_sz);
+	      if (!sym_value)
+		return grub_errno;
+	      for (block = 0; block < (sym_sz + blksz - 1) / blksz; block++)
+		{
+		  void *t;
+		  grub_size_t movesize;
+
+		  err = dmu_read (&(dnode_path->dn), block, &t, 0, data);
+		  if (err)
+		    return err;
+
+		  movesize = MIN (sym_sz - block * blksz, blksz);
+
+		  grub_memcpy (sym_value + block * blksz, t, movesize);
+		  grub_free (t);
+		}
+	      free_symval = 1;
+	    }	    
+	  path = path_buf = grub_malloc (sym_sz + grub_strlen (oldpath) + 1);
 	  if (!path_buf)
 	    {
 	      grub_free (oldpathbuf);
 	      return grub_errno;
 	    }
-	  grub_memcpy (path, 
-		       (char *) DN_BONUS(&dnode_path->dn.dn) + sizeof (znode_phys_t),
-		       sizeof (dnode_path->dn.dn.dn_bonus) - sizeof (znode_phys_t));
-	  path [sizeof (dnode_path->dn.dn.dn_bonus) - sizeof (znode_phys_t)] = 0;
+	  grub_memcpy (path, sym_value, sym_sz);
+	  if (free_symval)
+	    grub_free (sym_value);
+	  path [sym_sz] = 0;
 	  grub_memcpy (path + grub_strlen (path), oldpath, 
 		       grub_strlen (oldpath) + 1);
 	  
@@ -1324,7 +1382,6 @@
 	      grub_free (dn_new);
 	    }
 	}
-#endif
     }
 
   if (!err)
@@ -2248,7 +2305,7 @@
 grub_zfs_read (grub_file_t file, char *buf, grub_size_t len)
 {
   struct grub_zfs_data *data = (struct grub_zfs_data *) file->data;
-  int blksz, movesize;
+  grub_size_t blksz, movesize;
   grub_size_t length;
   grub_size_t read;
   grub_err_t err;
@@ -2302,7 +2359,7 @@
       data->file_start = blkid * blksz;
       data->file_end = data->file_start + blksz;
 
-      movesize = MIN (length, data->file_end - (int) file->offset - read);
+      movesize = MIN (length, data->file_end - file->offset - read);
 
       grub_memmove (buf, data->file_buf + file->offset + read
 		    - data->file_start, movesize);
--- a/include/grub/zfs/zio.h
+++ b/include/grub/zfs/zio.h
@@ -77,7 +77,15 @@
 	ZIO_COMPRESS_OFF,
 	ZIO_COMPRESS_LZJB,
 	ZIO_COMPRESS_EMPTY,
-	ZIO_COMPRESS_GZIP,
+	ZIO_COMPRESS_GZIP1,
+	ZIO_COMPRESS_GZIP2,
+	ZIO_COMPRESS_GZIP3,
+	ZIO_COMPRESS_GZIP4,
+	ZIO_COMPRESS_GZIP5,
+	ZIO_COMPRESS_GZIP6,
+	ZIO_COMPRESS_GZIP7,
+	ZIO_COMPRESS_GZIP8,
+	ZIO_COMPRESS_GZIP9,
 	ZIO_COMPRESS_FUNCTIONS
 };
 
