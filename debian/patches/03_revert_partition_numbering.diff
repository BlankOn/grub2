
Revert this commit which seems to break stuff.

-2006-06-05  Yoshinori K. Okuji  <okuji@enbug.org>
-
-	Count partitions from 1 instead of 0 in the string representation
-	of partitions. Still use 0-based internally.
-	
-	* partmap/sun.c (grub_sun_is_valid): A cosmetic change.
-	(sun_partition_map_iterate): Use grub_partition_t instead of
-	struct grub_partition *. Cast DESC->START_CYLINDER to
-	grub_uint64_t after converting the endian.
-	(sun_partition_map_probe): Subtract 1 for PARTNUM.
-	(sun_partition_map_get_name): Add 1 to P->INDEX.
-
-	* partmap/pc.c (grub_partition_parse): Subtract 1 for
-	PCDATA->DOS_PART.
-	(pc_partition_map_get_name): Add 1 into PCDATA->DOS_PART.
-
-	* partmap/gpt.c (gpt_partition_map_iterate): Initialize PARTNO to
-	zero instead of one.
-	(gpt_partition_map_probe): Subtract 1 for PARTNUM.
-	(gpt_partition_map_get_name): Add 1 into P->INDEX.
-
-	* partmap/apple.c (apple_partition_map_iterate): Change the type
-	of POS to unsigned.
-	(apple_partition_map_probe): Subtract 1 for PARTNUM.
-	(apple_partition_map_get_name): Add 1 into P->INDEX.
-
-	* partmap/amiga.c (amiga_partition_map_iterate): Change the type
-	of POS to unsigned.
-	(amiga_partition_map_iterate): Cast NEXT to grub_off_t to
-	calculate the offset of a partition.
-	(amiga_partition_map_probe): Subtract 1 for PARTNUM.
-	(amiga_partition_map_get_name): Add 1 into P->INDEX.
-
-	* partmap/acorn.c (acorn_partition_map_find): Change the type of
-	SECTOR to grub_disk_addr_t.
-	(acorn_partition_map_iterate): Likewise.
-	(acorn_partition_map_probe): Subtract 1 for PARTNUM.
-	Change the type of SECTOR to grub_disk_addr_t. Declare P on the
-	top.
-	(acorn_partition_map_get_name): Add 1 into P->INDEX.
-
-	* kern/i386/pc/init.c (make_install_device): Add 1 into
-	GRUB_INSTALL_DOS_PART.
-
-	* fs/iso9660.c (grub_iso9660_mount): Fixed a reversed
-	conditional.
-

Index: NEWS
===================================================================
RCS file: /sources/grub/grub2/NEWS,v
retrieving revision 1.25
diff -u -r1.25 NEWS
--- NEWS	5 Jun 2006 17:18:31 -0000	1.25
+++ NEWS	21 Sep 2006 21:44:39 -0000
@@ -1,8 +1,3 @@
-New in 1.95:
-
-* Number partitions from 1 instead of 0. For instance, the first
-  partition of "hd0" is now "hd0,1" but not "hd0,0".
-
 New in 1.94 - 2006-06-04:
 
 * Fix several serious bugs in HFS+.
Index: fs/iso9660.c
===================================================================
RCS file: /sources/grub/grub2/fs/iso9660.c,v
retrieving revision 1.4
diff -u -r1.4 iso9660.c
--- fs/iso9660.c	5 Jun 2006 17:18:31 -0000	1.4
+++ fs/iso9660.c	21 Sep 2006 21:44:41 -0000
@@ -236,7 +236,7 @@
       goto fail;
     }
 
-  if (grub_strncmp ((char *) data->voldesc.voldesc.magic, "CD001", 5) != 0)
+  if (grub_strncmp ((char *) data->voldesc.voldesc.magic, "CD001", 5) == 0)
     {
       grub_error (GRUB_ERR_BAD_FS, "not a iso9660 filesystem");
       goto fail;
@@ -268,7 +268,7 @@
   sua_size = rootdir.len - sua_pos;
 
   sua = grub_malloc (sua_size);
-  if (! sua)
+  if (!sua)
     goto fail;
   
   if (grub_disk_read (disk, (grub_le_to_cpu32 (data->voldesc.rootdir.first_sector)
@@ -622,7 +622,7 @@
 #endif
 
   data = grub_iso9660_mount (device->disk);
-  if (! data)
+  if (!data)
     goto fail;
   
   rootnode.data = data;
Index: kern/i386/pc/init.c
===================================================================
RCS file: /sources/grub/grub2/kern/i386/pc/init.c,v
retrieving revision 1.13
diff -u -r1.13 init.c
--- kern/i386/pc/init.c	5 Jun 2006 17:18:31 -0000	1.13
+++ kern/i386/pc/init.c	21 Sep 2006 21:44:41 -0000
@@ -1,6 +1,6 @@
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2002,2003,2004,2005,2006  Free Software Foundation, Inc.
+ *  Copyright (C) 2002, 2003, 2004, 2005  Free Software Foundation, Inc.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -64,7 +64,7 @@
 		grub_boot_drive & 0x7f);
   
   if (grub_install_dos_part >= 0)
-    grub_sprintf (dev + grub_strlen (dev), ",%u", grub_install_dos_part + 1);
+    grub_sprintf (dev + grub_strlen (dev), ",%u", grub_install_dos_part);
 
   if (grub_install_bsd_part >= 0)
     grub_sprintf (dev + grub_strlen (dev), ",%c", grub_install_bsd_part + 'a');
Index: partmap/acorn.c
===================================================================
RCS file: /sources/grub/grub2/partmap/acorn.c,v
retrieving revision 1.3
diff -u -r1.3 acorn.c
--- partmap/acorn.c	5 Jun 2006 17:18:31 -0000	1.3
+++ partmap/acorn.c	21 Sep 2006 21:44:41 -0000
@@ -51,7 +51,7 @@
 
 static grub_err_t
 acorn_partition_map_find (grub_disk_t disk, struct linux_part *m,
-			  grub_disk_addr_t *sector)
+			  unsigned int *sector)
 {
   struct grub_acorn_boot_block boot;
   grub_err_t err;
@@ -61,8 +61,8 @@
   int i;
 
   err = grub_disk_read (disk, 0xC00 / GRUB_DISK_SECTOR_SIZE, 0,
-			sizeof (struct grub_acorn_boot_block),
-			(char *) &boot);
+				   sizeof (struct grub_acorn_boot_block),
+				   (char *)&boot);
   if (err)
     return err;
 
@@ -82,7 +82,7 @@
 
   return grub_disk_read (disk, *sector, 0,
 			 sizeof (struct linux_part) * LINUX_MAP_ENTRIES,
-			 (char *) m);
+			 (char *)m);
 
 fail:
   return grub_error (GRUB_ERR_BAD_PART_TABLE,
@@ -100,7 +100,7 @@
   struct grub_disk raw;
   struct linux_part map[LINUX_MAP_ENTRIES];
   int i;
-  grub_disk_addr_t sector;
+  unsigned int sector;
   grub_err_t err;
 
   /* Enforce raw disk access.  */
@@ -119,7 +119,7 @@
 	  && map[i].magic != LINUX_SWAP_MAGIC)
 	return GRUB_ERR_NONE;
 
-      part.start = sector + map[i].start;
+      part.start = (grub_disk_addr_t)sector + map[i].start;
       part.len = map[i].size;
       part.offset = 6;
       part.index = i;
@@ -137,11 +137,10 @@
 {
   struct linux_part map[LINUX_MAP_ENTRIES];
   struct grub_disk raw = *disk;
-  unsigned long partnum = grub_strtoul (str, 0, 10) - 1;
-  grub_disk_addr_t sector;
+  unsigned long partnum = grub_strtoul (str, 0, 10);
+  unsigned int sector;
   grub_err_t err;
-  grub_partition_t p;
-  
+
   /* Enforce raw disk access.  */
   raw.partition = 0;
 
@@ -157,11 +156,11 @@
       && map[partnum].magic != LINUX_SWAP_MAGIC)
     goto fail;
 
-  p = grub_malloc (sizeof (struct grub_partition));
-  if (! p)
+  grub_partition_t p = grub_malloc (sizeof (struct grub_partition));
+  if (!p)
     return 0;
 
-  p->start = sector + map[partnum].start;
+  p->start = (grub_disk_addr_t)sector + map[partnum].start;
   p->len = map[partnum].size;
   p->offset = 6;
   p->index = partnum;
@@ -179,10 +178,10 @@
   char *name;
 
   name = grub_malloc (13);
-  if (! name)
+  if (!name)
     return 0;
 
-  grub_sprintf (name, "%d", p->index + 1);
+  grub_sprintf (name, "%d", p->index);
   return name;
 }
 
Index: partmap/amiga.c
===================================================================
RCS file: /sources/grub/grub2/partmap/amiga.c,v
retrieving revision 1.6
diff -u -r1.6 amiga.c
--- partmap/amiga.c	5 Jun 2006 17:18:31 -0000	1.6
+++ partmap/amiga.c	21 Sep 2006 21:44:41 -0000
@@ -84,7 +84,7 @@
   struct grub_disk raw;
   int partno = 0;
   int next = -1;
-  unsigned pos;
+  int pos;
   
   /* Enforce raw disk access.  */
   raw = *disk;
@@ -94,7 +94,8 @@
   for (pos = 0; pos < 15; pos++)
     {
       /* Read the RDSK block which is a descriptor for the entire disk.  */
-      if (grub_disk_read (&raw, pos, 0, sizeof (rdsk), (char *) &rdsk))
+      if (grub_disk_read (&raw, pos, 0,
+			  sizeof (rdsk),  (char *) &rdsk))
 	return grub_errno;
       
       if (grub_strcmp ((char *) rdsk.magic, "RDSK") == 0)
@@ -115,7 +116,8 @@
       struct grub_amiga_partition apart;
      
       /* Read the RDSK block which is a descriptor for the entire disk.  */
-      if (grub_disk_read (&raw, next, 0, sizeof (apart), (char *) &apart))
+      if (grub_disk_read (&raw, next, 0,
+			  sizeof (apart),  (char *) &apart))
 	return grub_errno;
       
       /* Calculate the first block and the size of the partition.  */
@@ -127,7 +129,7 @@
 		  * grub_be_to_cpu32 (apart.heads)
 		  * grub_be_to_cpu32 (apart.block_per_track));
       
-      part.offset = (grub_off_t) next * 512;
+      part.offset = next * 512;
       part.index = partno;
       part.partmap = &grub_amiga_partition_map;
       
@@ -153,7 +155,7 @@
     
   int find_func (grub_disk_t d __attribute__ ((unused)),
 		 const grub_partition_t partition)
-    {
+      {
       if (partnum == partition->index)
 	{
 	  p = (grub_partition_t) grub_malloc (sizeof (*p));
@@ -168,7 +170,7 @@
     }
   
   /* Get the partition number.  */
-  partnum = grub_strtoul (s, 0, 10) - 1;
+  partnum = grub_strtoul (s, 0, 10);
   if (grub_errno)
     {
       grub_error (GRUB_ERR_BAD_FILENAME, "invalid partition");
@@ -195,7 +197,7 @@
   if (! name)
     return 0;
 
-  grub_sprintf (name, "%d", p->index + 1);
+  grub_sprintf (name, "%d", p->index);
   return name;
 }
 
Index: partmap/apple.c
===================================================================
RCS file: /sources/grub/grub2/partmap/apple.c,v
retrieving revision 1.8
diff -u -r1.8 apple.c
--- partmap/apple.c	5 Jun 2006 17:18:31 -0000	1.8
+++ partmap/apple.c	21 Sep 2006 21:44:41 -0000
@@ -1,7 +1,7 @@
 /* apple.c - Read macintosh partition tables.  */
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2002,2004,2005,2006  Free Software Foundation, Inc.
+ *  Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -102,7 +102,7 @@
   struct grub_apple_part apart;
   struct grub_disk raw;
   int partno = 0;
-  unsigned pos = GRUB_DISK_SECTOR_SIZE;
+  int pos = GRUB_DISK_SECTOR_SIZE;
 
   /* Enforce raw disk access.  */
   raw = *disk;
@@ -113,7 +113,7 @@
   for (;;)
     {
       if (grub_disk_read (&raw, pos / GRUB_DISK_SECTOR_SIZE,
-			  pos % GRUB_DISK_SECTOR_SIZE,
+		      pos % GRUB_DISK_SECTOR_SIZE,
 			  sizeof (struct grub_apple_part),  (char *) &apart))
 	return grub_errno;
 
@@ -140,8 +140,7 @@
       if (hook (disk, &part))
 	return grub_errno;
 
-      if (grub_be_to_cpu32 (apart.first_phys_block)
-	  == GRUB_DISK_SECTOR_SIZE * 2)
+      if (grub_be_to_cpu32 (apart.first_phys_block) == GRUB_DISK_SECTOR_SIZE * 2)
 	return 0;
 
       pos += sizeof (struct grub_apple_part);
@@ -182,7 +181,7 @@
     }
   
   /* Get the partition number.  */
-  partnum = grub_strtoul (s, 0, 10) - 1;
+  partnum = grub_strtoul (s, 0, 10);
   if (grub_errno)
     {
       grub_error (GRUB_ERR_BAD_FILENAME, "invalid partition");
@@ -209,7 +208,7 @@
   if (! name)
     return 0;
 
-  grub_sprintf (name, "%d", p->index + 1);
+  grub_sprintf (name, "%d", p->index);
   return name;
 }
 
Index: partmap/gpt.c
===================================================================
RCS file: /sources/grub/grub2/partmap/gpt.c,v
retrieving revision 1.4
diff -u -r1.4 gpt.c
--- partmap/gpt.c	5 Jun 2006 17:18:31 -0000	1.4
+++ partmap/gpt.c	21 Sep 2006 21:44:41 -0000
@@ -79,7 +79,7 @@
   struct grub_disk raw;
   struct grub_pc_partition_mbr mbr;
   grub_uint64_t entries;
-  int partno = 0;
+  int partno = 1;
   unsigned int i;
   int last_offset = 0;
 
@@ -157,7 +157,7 @@
     
   int find_func (grub_disk_t d __attribute__ ((unused)),
 		 const grub_partition_t partition)
-    {
+      {
       if (partnum == partition->index)
 	{
 	  p = (grub_partition_t) grub_malloc (sizeof (*p));
@@ -172,7 +172,7 @@
     }
   
   /* Get the partition number.  */
-  partnum = grub_strtoul (s, 0, 10) - 1;
+  partnum = grub_strtoul (s, 0, 10);
   if (grub_errno)
     {
       grub_error (GRUB_ERR_BAD_FILENAME, "invalid partition");
@@ -199,7 +199,7 @@
   if (! name)
     return 0;
 
-  grub_sprintf (name, "%d", p->index + 1);
+  grub_sprintf (name, "%d", p->index);
   return name;
 }
 
Index: partmap/pc.c
===================================================================
RCS file: /sources/grub/grub2/partmap/pc.c,v
retrieving revision 1.9
diff -u -r1.9 pc.c
--- partmap/pc.c	5 Jun 2006 17:18:31 -0000	1.9
+++ partmap/pc.c	21 Sep 2006 21:44:41 -0000
@@ -55,9 +55,8 @@
   /* Initialize some of the fields with invalid values.  */
   pcdata->bsd_part = pcdata->dos_type = pcdata->bsd_type = p->index = -1;
 
-  /* Get the DOS partition number. The number is counted from one for
-     the user interface, and from zero internally.  */
-  pcdata->dos_part = grub_strtoul (s, &s, 0) - 1;
+  /* Get the DOS partition number.  */
+  pcdata->dos_part = grub_strtoul (s, &s, 0);
   
   if (grub_errno)
     {
@@ -238,7 +237,6 @@
 		 const grub_partition_t partition)
     {
       struct grub_pc_partition *partdata = partition->data;
-
       if ((pcdata->dos_part == partdata->dos_part || pcdata->dos_part == -1)
 	  && pcdata->bsd_part == partdata->bsd_part)
 	{
@@ -285,11 +283,9 @@
     return 0;
 
   if (pcdata->bsd_part < 0)
-    grub_sprintf (name, "%d", pcdata->dos_part + 1);
-  else if (pcdata->dos_part < 0)
-    grub_sprintf (name, "%c", pcdata->bsd_part + 'a');
+    grub_sprintf (name, "%d", pcdata->dos_part);
   else
-    grub_sprintf (name, "%d,%c", pcdata->dos_part + 1, pcdata->bsd_part + 'a');
+    grub_sprintf (name, "%d,%c", pcdata->dos_part, pcdata->bsd_part + 'a');
 
   return name;
 }
Index: partmap/sun.c
===================================================================
RCS file: /sources/grub/grub2/partmap/sun.c,v
retrieving revision 1.4
diff -u -r1.4 sun.c
--- partmap/sun.c	5 Jun 2006 17:18:31 -0000	1.4
+++ partmap/sun.c	21 Sep 2006 21:44:41 -0000
@@ -1,7 +1,7 @@
 /* sun.c - Read SUN style partition tables.  */
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2002,2005,2006 Free Software Foundation, Inc.
+ *  Copyright (C) 2002, 2005 Free Software Foundation, Inc.
  *
  *  GRUB is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -78,13 +78,9 @@
 {
   grub_uint16_t *pos;
   grub_uint16_t sum = 0;
-  
-  for (pos = (grub_uint16_t *) label;
-       pos < (grub_uint16_t *) (label + 1);
-       pos++)
+  for (pos = (grub_uint16_t *) label; pos < (grub_uint16_t *) (label + 1); pos++)
     sum ^= *pos;
-  
-  return ! sum;
+  return !sum;
 }
 
 static grub_err_t
@@ -92,16 +88,14 @@
                            int (*hook) (grub_disk_t disk,
 					const grub_partition_t partition))
 {
-  grub_partition_t p;
+  struct grub_partition *p;
   struct grub_disk raw;
   struct grub_sun_block block;
   int partnum;
-  
   raw = *disk;
   raw.partition = 0;
-  
-  p = (grub_partition_t) grub_malloc (sizeof (struct grub_partition));
-  if (! p)
+  p = (struct grub_partition *) grub_malloc (sizeof (struct grub_partition));
+  if (!p)
     return grub_errno;
 
   p->offset = 0;
@@ -112,25 +106,20 @@
     {
       if (GRUB_PARTMAP_SUN_MAGIC != grub_be_to_cpu16 (block.magic))
 	grub_error (GRUB_ERR_BAD_PART_TABLE, "not a sun partiton table");
-      
-      if (! grub_sun_is_valid (&block))
+      if (!grub_sun_is_valid (&block))
 	grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid checksum");
-      
       /* Maybe another error value would be better, because partition
 	 table _is_ recognised but invalid.  */
       for (partnum = 0; partnum < GRUB_PARTMAP_SUN_MAX_PARTS; partnum++)
 	{
-	  struct grub_sun_partition_descriptor *desc;
-	  
-	  if (block.infos[partnum].id == 0
-	      || block.infos[partnum].id == GRUB_PARTMAP_SUN_WHOLE_DISK_ID)
+	  if (block.infos[partnum].id == 0 ||
+	      block.infos[partnum].id == GRUB_PARTMAP_SUN_WHOLE_DISK_ID)
 	    continue;
-
-	  desc = &block.partitions[partnum];
-	  p->start = ((grub_uint64_t) grub_be_to_cpu32 (desc->start_cylinder)
-		      * grub_be_to_cpu16 (block.ntrks)
-		      * grub_be_to_cpu16 (block.nsect));
-	  p->len = grub_be_to_cpu32 (desc->num_sectors);
+	  p->start = grub_be_to_cpu32
+	    (block.partitions[partnum].start_cylinder)
+	    * grub_be_to_cpu16 (block.ntrks)
+	    * grub_be_to_cpu16 (block.nsect);
+	  p->len = grub_be_to_cpu32 (block.partitions[partnum].num_sectors);
 	  p->index = partnum;
 	  if (p->len)
 	    {
@@ -139,7 +128,6 @@
 	    }
 	}
     }
-  
   grub_free (p);
 
   return grub_errno;
@@ -162,15 +150,13 @@
           p = (grub_partition_t) grub_malloc (sizeof (*p));
           if (p)
             grub_memcpy (p, partition, sizeof (*p));
-	  
           return 1;
         }
-      
       return 0;
     }
 
   grub_errno = GRUB_ERR_NONE;
-  partnum = grub_strtoul (s, 0, 10) - 1;
+  partnum = grub_strtoul (s, 0, 10);
   if (grub_errno == GRUB_ERR_NONE)
     {
       if (sun_partition_map_iterate (disk, find_func))
@@ -184,7 +170,6 @@
       grub_error (GRUB_ERR_BAD_FILENAME, "invalid partition");
       p = 0;
     }
-  
   return p;
 }
 
@@ -192,11 +177,9 @@
 sun_partition_map_get_name (const grub_partition_t p)
 {
   char *name;
-  
   name = grub_malloc (13);
   if (name)
-    grub_sprintf (name, "%d", p->index + 1);
-  
+    grub_sprintf (name, "%d", p->index);
   return name;
 }
 
